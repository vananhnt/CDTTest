<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>CDE: A package for integrability of PDEs</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<!-- 3,html --> 
<meta name="src" content="manual.tex"> 
<link rel="stylesheet" type="text/css" href="manual.css"> 
</head><body 
>
<p align="centre"><img src="redlogo.png" width=621 height=60 border=0 alt="REDUCE"></p><table cellspacing="5"><tr><td class="clinks"><a 
href="manualch16.html#manualse103.html" >Up</a></td><td class="clinks"><a 
href="manualse104.html" >Next</a></td><td class="clinks"><a 
href="manualse102.html" >Prev</a></td><td class="clinks"><a 
href="manualse102.html#tailmanualse102.html" >PrevTail</a></td><td class="clinks"><a 
href="#tailmanualse103.html">Tail</a></td></tr></table><h3 class="sectionHead"><span class="titlemark">16.12    </span> <a 
 id="x131-31500016.12"></a>CDE: A package for integrability of PDEs</h3>
<!--l. 241--><p class="noindent" >Author: Raffaele Vitolo
<a 
 id="dx131-315001"></a>
<a 
 id="dx131-315002"></a>
<!--l. 39--><p class="noindent" >We describe CDE, a REDUCE package devoted to differential-geometric computations
on Differential Equations (DEs, for short).
<!--l. 42--><p class="noindent" >We will give concrete recipes for computations in the geometry of differential equations:
higher symmetries, conservation laws, Hamiltonian operators and their Schouten bracket,
recursion operators. All programs discussed here are shipped together with the
CDE sources, inside the REDUCE sources. The mathematical theory on which
computations are based can be found in refs.&#x00A0;<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>. We invite the interested reader to
have a look at the website <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span> which contains useful reseources in the above
mathematical area. A book on integrable systems and CDE is currently being written <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>
with more examples and more detailed explanations about the mathematical
part.
<!--l. 53--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.1    </span> <a 
 id="x131-31600016.12.1"></a>Introduction: why CDE?</h4>
<!--l. 56--><p class="noindent" >CDE is a REDUCE package for differential-geometric computations for DEs. The
package aims at defining differential operators in total derivatives and computing with
them. Such operators are called <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span><span 
class="ptmri8t-x-x-109">-differential operators </span>(see <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>).
<!--l. 61--><p class="noindent" >CDE depends on the REDUCE package CDIFF for constructing total derivatives. CDIFF
was developed by Gragert and Kersten for symmetry computations in DEs, and later
extended by Roelofs and Post.
<!--l. 65--><p class="noindent" >There are many software packages that can compute symmetries and conservation laws;
many of them run on Mathematica or Maple. Those who run on REDUCE were written
by M.C. Nucci <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>, F. Oliveri (<span 
class="ptmrc8t-x-x-109">R<span 
class="small-caps">E</span>L<span 
class="small-caps">I</span><span 
class="small-caps">E</span></span>, <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>), F. Schwartz (SPDE, REDUCE official
distribution) T. Wolf (APPLYSYM and CONLAW in the official REDUCE&#x00A0;distribution,
<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>).
<!--l. 72--><p class="noindent" >The development of CDE started from the idea that a computer algebra tool for the
investigation of integrability-related structures of PDEs still does not exist in the public
domain. We are only aware of a Mathematica package that may find recursion operators
                                                                     

                                                                     
under quite restrictive hypotheses <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 77--><p class="noindent" >CDE is especially designed for computations of integrability-related structures (such as
Hamiltonian, symplectic and recursion operators) for systems of differential equations
with an arbitrary number of independent or dependent variables. On the other hand CDE
is also capable of (generalized) symmetry and conservation laws computations. The aim
of this guide is to introduce the reader to computations of integrability related structures
using CDE.
<!--l. 85--><p class="noindent" >The current version of CDE, 2.0, has the following features:
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x131-316002x1">It is able to do standard computations in integrable systems like determining
     systems for generalized symmetries and conservation laws. However, CDE
     has not been programmed with this purpose in mind.
     </li>
     <li 
  class="enumerate" id="x131-316004x2">CDE is able to compute linear overdetermined systems of partial differential
     equations   whose   solutions   are   Hamiltonian,   symplectic   or   recursion
     operators.  Such  equations  may  be  solved  by  different  techniques;  one
     of  the  possibilities  is  to  use  CRACK,  a  REDUCE  package  for  solving
     overdetermined systems of PDEs <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
     </li>
     <li 
  class="enumerate" id="x131-316006x3">CDE can compute linearization (or Fréchet derivatives) of vector functions
     and adjoints of differential operators.
     </li>
     <li 
  class="enumerate" id="x131-316008x4">CDE  is  able  to  compute  Schouten  brackets  between  multivectors.  This
     can  be  used  <span 
class="ptmri8t-x-x-109">eg  </span>to  check  Hamiltonianity  of  an  operator  or  to  check  their
     compatibility.</li></ol>
<!--l. 102--><p class="noindent" >At the moment the papers <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span> have been written using CDE, and more
research by CDE on integrable systems is in progress.
<!--l. 107--><p class="noindent" >The readers are warmly invited to send questions, comments, etc., both on the
computations and on the technical aspects of installation and configuration of REDUCE,
to the author of this document.
<!--l. 111--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Acknowledgements. </span>I&#8217;d like to thank Paul H.M. Kersten, who explained to me how to
use the original CDIFF package for several computations of interest in the Geometry of
Differential Equations. When I started writing CDE I was substantially helped by A.C.
Norman in understanding many features of Reduce which were deeply hidden in the
source code and not well documented. This also led to writing a manual of Reduce&#8217;s
internals for programmers <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. Moreover, I&#8217;d like to thank the developers of the
REDUCE mailing list for their prompt replies with solutions to my problems. On the
mathematical side, I would like to thank J.S. Krasil&#8217;shchik and A.M. Verbovetsky for
                                                                     

                                                                     
constant support and stimulating discussions which led me to write the software. Thanks
are also due to B.A. Dubrovin, M. Casati, E.V. Ferapontov, P. Lorenzoni, M.
Marvan, V. Novikov, A. Savoldi, A. Sergyeyev, M.V. Pavlov for many interesting
discussions.
<!--l. 126--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.2    </span> <a 
 id="x131-31700016.12.2"></a>Jet space of even and odd variables, and total derivatives</h4>
<!--l. 129--><p class="noindent" >The mathematical theory for jets of even (<span 
class="ptmri8t-x-x-109">ie </span>standard) variables and total derivatives can
be found in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 132--><p class="noindent" >Let us consider the space <span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">n</span></sup> <span 
class="cmsy-10x-x-109">&#x00D7; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">m</span></sup>, with coordinates <span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">x</span><sup><span 
class="cmmi-8">&#x03BB;</span></sup><span 
class="cmmi-10x-x-109">,u</span><sup><span 
class="cmmi-8">i</span></sup><span 
class="cmr-10x-x-109">)</span>, <span 
class="cmr-10x-x-109">1 </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">&#x03BB; </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">n</span>, <span 
class="cmr-10x-x-109">1 </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">i </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">m</span>.
We say <span 
class="cmmi-10x-x-109">x</span><sup><span 
class="cmmi-8">&#x03BB;</span></sup> to be <span 
class="ptmri8t-x-x-109">independent variables </span>and <span 
class="cmmi-10x-x-109">u</span><sup><span 
class="cmmi-8">i</span></sup> to be <span 
class="ptmri8t-x-x-109">dependent variables</span>. Let us
introduce the <span 
class="ptmri8t-x-x-109">jet space </span><span 
class="cmmi-10x-x-109">J</span><sup><span 
class="cmmi-8">r</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">n,m</span><span 
class="cmr-10x-x-109">)</span>. This is the space with coordinates <span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">x</span><sup><span 
class="cmmi-8">&#x03BB;</span></sup><span 
class="cmmi-10x-x-109">,u</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><sup><span 
class="cmmi-8">i</span></sup><span 
class="cmr-10x-x-109">)</span>,
where <span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><sup><span 
class="cmmi-8">i</span></sup> is defined as follows. If <span 
class="cmmi-10x-x-109">s</span><span 
class="cmr-10x-x-109">:</span> <span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">n</span></sup> <span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">m</span></sup> is a differentiable function,
then
<center class="math-display" >
<img 
src="manual105x.png" alt="                |&#x03C3;|  i
ui&#x2218; s(x) = ---&#x2202;---(u--&#x2218;s)----.
 &#x03C3;         (&#x2202;x1 )&#x03C3;1 &#x22C5;&#x22C5;&#x22C5;(&#x2202;xn )&#x03C3;n
" class="math-display" ></center>
<!--l. 141--><p class="nopar" >
Here <span 
class="cmmi-10x-x-109">&#x03C3; </span><span 
class="cmr-10x-x-109">= (</span><span 
class="cmmi-10x-x-109">&#x03C3;</span><sub><span 
class="cmr-8">1</span></sub><span 
class="cmmi-10x-x-109">,</span><span 
class="cmmi-10x-x-109">&#x2026;</span><span 
class="cmmi-10x-x-109">,&#x03C3;</span><sub><span 
class="cmmi-8">n</span></sub><span 
class="cmr-10x-x-109">) </span><span 
class="cmsy-10x-x-109">&#x2208; </span><span 
class="msbm-10x-x-109">&#x2115;</span><sup><span 
class="cmmi-8">n</span></sup> is a multiindex. We set <span 
class="cmsy-10x-x-109">|</span><span 
class="cmmi-10x-x-109">&#x03C3;</span><span 
class="cmsy-10x-x-109">| </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">&#x03C3;</span><sub><span 
class="cmr-8">1</span></sub> <span 
class="cmr-10x-x-109">+</span> <img 
src="manual106x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" > <span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">&#x03C3;</span><sub><span 
class="cmmi-8">n</span></sub>. If <span 
class="cmmi-10x-x-109">&#x03C3; </span><span 
class="cmr-10x-x-109">= (0</span><span 
class="cmmi-10x-x-109">,</span><span 
class="cmmi-10x-x-109">&#x2026;</span><span 
class="cmmi-10x-x-109">,</span><span 
class="cmr-10x-x-109">0)</span>
we set <span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><sup><span 
class="cmmi-8">i</span></sup> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">u</span><sup><span 
class="cmmi-8">i</span></sup>.
<!--l. 146--><p class="noindent" >CDE is first of all a program which is able to create a <span 
class="ptmri8t-x-x-109">finite order jet space </span>inside
REDUCE. To this aim, issue the command
                                                                     

                                                                     
<div class="verbatim" id="verbatim-604">
load_package&#x00A0;cde;
</div>
<!--l. 150--><p class="nopar" > Then, CDE needs to know the variables and the maximal order of derivatives. The input
can be organized as in the following example: <a 
 id="dx131-317001"></a> <a 
 id="dx131-317002"></a> <a 
 id="dx131-317003"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-605">
indep_var:={x,t}$
&#x00A0;<br />dep_var:={u,v}$
&#x00A0;<br />total_order:=10$
</div>
<!--l. 160--><p class="nopar" > Here
     <ul class="itemize1">
     <li class="itemize"><span 
class="pcrr8t-x-x-109">indep_var </span>is the list of independent variables;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">dep_var </span>is the list of dependent variables;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">total_order </span>is the maximal order of derivatives.</li></ul>
<!--l. 168--><p class="noindent" >Two more parameters can be set for convenience:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-606">
statename:=~jetuv_state.red~$
&#x00A0;<br />resname:=~jetuv_res.red~$
</div>
<!--l. 172--><p class="nopar" > These are the name of the output file for recording the internal state of the program
<span 
class="pcrr8t-x-x-109">cde.red </span>(and for debugging purposes), and the name of the file containing results of
the computation.
<!--l. 177--><p class="noindent" >The main routine in <span 
class="pcrr8t-x-x-109">cde.red </span>is called as follows: <a 
 id="dx131-317004"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-607">
cde({indep_var,dep_var,{},total_order},{})$
</div>
<!--l. 181--><p class="nopar" > Here the two empty lists are placeholders; they are of interest for computations with odd
variables/differential equations. The function <span 
class="pcrr8t-x-x-109">cde</span> defines derivative symbols of the
type:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-608">
u_x,v_t,u_2xt,v_xt,v_2x3t,...
</div>
<!--l. 187--><p class="nopar" > Note that the symbol <span 
class="pcrr8t-x-x-109">v_tx </span>does not exist in the jet space. Indeed, introducing all
possible permutations of independent variables in indices would increase the complexity
and slow down every computation.
<!--l. 192--><p class="noindent" >Two lists generated by CDE can be useful: <span 
class="pcrr8t-x-x-109">all_der_id </span>and <span 
class="pcrr8t-x-x-109">all_odd_id</span>, which
are, respectively, the lists of identifiers of all even and odd variables.
<!--l. 196--><p class="noindent" >Other lists are generated by CDE, but they are accessible in REDUCE symbolic mode
only. Please check the file <span 
class="pcrr8t-x-x-109">global.txt </span>to know the names of the lists.
<a 
 id="dx131-317005"></a>
<!--l. 201--><p class="noindent" >It can be useful to inspect the output generated by the function <span 
class="pcrr8t-x-x-109">cde </span>and the above lists in
particular. All that data can be saved by the function:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-609">
save_cde_state(statename)$
</div>
<!--l. 205--><p class="nopar" >
<a 
 id="dx131-317006"></a>
<a 
 id="dx131-317007"></a>
<a 
 id="dx131-317008"></a>
<!--l. 210--><p class="noindent" >CDE has a few procedures involving the jet space, namely:
     <ul class="itemize1">
     <li class="itemize"><span 
class="pcrr8t-x-x-109">jet_fiber_dim(jorder) </span>returns the number of derivative coordinates
     <span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><sup><span 
class="cmmi-8">i</span></sup> with <span 
class="cmsy-10x-x-109">|</span><span 
class="cmmi-10x-x-109">&#x03C3;</span><span 
class="cmsy-10x-x-109">| </span>equal to <span 
class="pcrr8t-x-x-109">jorder</span>;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">jet_dim(jorder) </span>returns the number of derivative coordinates <span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><sup><span 
class="cmmi-8">i</span></sup> with
     <span 
class="cmr-10x-x-109">0 </span><span 
class="cmsy-10x-x-109">&#x2264;|</span><span 
class="cmmi-10x-x-109">&#x03C3;</span><span 
class="cmsy-10x-x-109">| </span>and <span 
class="cmsy-10x-x-109">|</span><span 
class="cmmi-10x-x-109">&#x03C3;</span><span 
class="cmsy-10x-x-109">| </span>equal to <span 
class="pcrr8t-x-x-109">jorder</span>;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">selectvars(par,orderofder,depvars,vars)</span>
     returns all derivative coordinates (even if <span 
class="pcrr8t-x-x-109">par=0</span>, odd if <span 
class="pcrr8t-x-x-109">par=1</span>) of order
     <span 
class="pcrr8t-x-x-109">orderofder </span>of the list of dependent variables <span 
class="pcrr8t-x-x-109">depvars </span>which belong to
     the set of derivative coordinates <span 
class="pcrr8t-x-x-109">vars</span>.</li></ul>
<!--l. 223--><p class="noindent" >The function <span 
class="pcrr8t-x-x-109">cde </span>defines total derivatives truncated at the order <span 
class="pcrr8t-x-x-109">total_order</span>. Their
coordinate expressions are of the form
<table 
class="equation"><tr><td><a 
 id="x131-317009r46"></a>
<center class="math-display" >
<img 
src="manual107x.png" alt="D &#x03BB; = -&#x2202;--+ ui  -&#x2202;--,
      &#x2202;x&#x03BB;    &#x03C3;&#x03BB; &#x2202;ui&#x03C3;
" class="math-display" ></center></td><td class="equation-label">(16.46)</td></tr></table>
<!--l. 230--><p class="nopar" >
where <span 
class="cmmib-10x-x-109">&#x03C3;</span> is a multiindex.
                                                                     

                                                                     
<!--l. 233--><p class="noindent" >The total derivative of an argument <span 
class="cmmi-10x-x-109">&#x03C6; </span>is invoked as follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-610">
td(phi,x,2);
&#x00A0;<br />td(phi,x,t,3);
</div>
<!--l. 237--><p class="nopar" > the syntax closely follows REDUCE&#8217;s syntax for standard derivatives <span 
class="pcrr8t-x-x-109">df</span>; the above
expression translates to <span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmmi-8">x</span></sub><span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmmi-8">x</span></sub><span 
class="cmmi-10x-x-109">&#x03C6;</span>, or <span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmsy-8">{</span><span 
class="cmr-8">2</span><span 
class="cmmi-8">,</span><span 
class="cmr-8">0</span><span 
class="cmsy-8">}</span></sub><span 
class="cmmi-10x-x-109">&#x03C6; </span>in multiindex notation.
<!--l. 242--><p class="noindent" >When in total derivatives there is a coefficient of order higher than maximal this is
replaced by the identifier <span 
class="pcrr8t-x-x-109">letop</span>, which is a function that depends on independent
variables. If such a function (or its derivatives) appears during computations it is likely
that we went too close to the highest order variables that we defined in the file. All results
of computations are scanned for the presence of such variables by default, and if the
presence of <span 
class="pcrr8t-x-x-109">letop </span>is detected the computation is stopped with an error message. This
usually means that we need to extend the order of the jet space, just by increasing the
number <span 
class="pcrr8t-x-x-109">total_order</span>.
<!--l. 252--><p class="noindent" >Note that in the folder containing all examples there is also a shell script, <span 
class="pcrr8t-x-x-109">rrr.sh</span>
(works only under <span 
class="pcrr8t-x-x-109">bash</span>, a GNU/Linux command interpreter) which can be used to run
reduce on a given CDE program. When an error message about <span 
class="pcrr8t-x-x-109">letop </span>is issued the
script reruns the computation with a new value of <span 
class="pcrr8t-x-x-109">total_order </span>one unity higher than
the previous one.
<!--l. 259--><p class="noindent" >The function that checks an expression for the presence of <span 
class="pcrr8t-x-x-109">letop </span>is <span 
class="pcrr8t-x-x-109">check_letop</span>. If
you wish to switch off this kind of check in order to increase the speed, the switch
<span 
class="pcrr8t-x-x-109">checkord</span><a 
 id="dx131-317010"></a><a 
 id="dx131-317011"></a><a 
 id="dx131-317012"></a> must be set off:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-611">
off&#x00A0;checkord;
</div>
<!--l. 265--><p class="nopar" >
<a 
 id="dx131-317013"></a>
<a 
 id="dx131-317014"></a>
<!--l. 269--><p class="noindent" >The computation of total derivatives of a huge expression can be extremely time and
resources consuming. In some cases it is a good idea to disable the expansion of the total
derivative and leave an expression of the type <span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><span 
class="cmmi-10x-x-109">&#x03C6; </span>as indicated. This is achieved by the
command
                                                                     

                                                                     
<div class="verbatim" id="verbatim-612">
noexpand_td();
</div>
<!--l. 275--><p class="nopar" > If you wish to restore the default behaviour, do
                                                                     

                                                                     
<div class="verbatim" id="verbatim-613">
expand_td();
</div>
<!--l. 279--><p class="nopar" >
<a 
 id="dx131-317015"></a>
<!--l. 282--><p class="noindent" >CDE can also compute on jets of supermanifolds. The theory can be found in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>.
The input can be organized as follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-614">
indep_var:={x,t}$
&#x00A0;<br />dep_var:={u,v}$
&#x00A0;<br />odd_var:={p,q}
&#x00A0;<br />total_order:=10$
</div>
<!--l. 289--><p class="nopar" > Here <span 
class="pcrr8t-x-x-109">odd_var </span>is the list of odd variables. The call
                                                                     

                                                                     
<div class="verbatim" id="verbatim-615">
cde({indep_var,dep_var,odd_var,total_order},{})$
</div>
<!--l. 293--><p class="nopar" > will create the jet space of the supermanifold described by the independent variables
and the even and odd dependent variables, up to the order <span 
class="pcrr8t-x-x-109">total_order</span>.
Total derivatives truncated at the order <span 
class="pcrr8t-x-x-109">total_order </span>will also include odd
derivatives:
<table 
class="equation"><tr><td><a 
 id="x131-317016r47"></a>
<center class="math-display" >
<img 
src="manual108x.png" alt="       &#x2202;         &#x2202;         &#x2202;
D &#x03BB; = --&#x03BB;-+ ui&#x03C3;&#x03BB; --i-+ pi&#x03C3;&#x03BB; --i,
      &#x2202;x        &#x2202;u&#x03C3;       &#x2202;p&#x03C3;
" class="math-display" ></center></td><td class="equation-label">(16.47)</td></tr></table>
<!--l. 302--><p class="nopar" >
where <span 
class="cmmib-10x-x-109">&#x03C3;</span> is a multiindex. The considerations on expansion and <span 
class="pcrr8t-x-x-109">letop </span>apply in this case
too.
<a 
 id="dx131-317017"></a>
<!--l. 307--><p class="noindent" >Odd variables can appear in anticommuting products; this is represented as
                                                                     

                                                                     
<div class="verbatim" id="verbatim-616">
ext(p,p_2xt),ext(p_x,q_t,q_x2t),...
</div>
<!--l. 310--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">ext(p_2xt,p) = - ext(p,p_2xt) </span>and the variables are arranged in a
unique way terms of an internal ordering. Indeed, the internal representation of odd
variables and their products (not intended for normal users!) is
                                                                     

                                                                     
<div class="verbatim" id="verbatim-617">
ext(3,23),ext(1,3,5),...
</div>
<!--l. 317--><p class="nopar" > as all odd variables and their derivatives are indexed by integers. <a 
 id="dx131-317018"></a> Note that <span 
class="pcrr8t-x-x-109">p </span>and
<span 
class="pcrr8t-x-x-109">ext(p) </span>are just the same. The odd product of two expressions <span 
class="cmmi-10x-x-109">&#x03C6; </span>and <span 
class="cmmi-10x-x-109">&#x03C8; </span>is achieved by
the CDIFF function
                                                                     

                                                                     
<div class="verbatim" id="verbatim-618">
super_product(phi,psi);
</div>
<!--l. 324--><p class="nopar" > The derivative of an expression <span 
class="cmmi-10x-x-109">&#x03C6; </span>with respect to an odd variable <span 
class="cmmi-10x-x-109">p </span>is achieved
by<a 
 id="dx131-317019"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-619">
df_odd(phi,p);
</div>
<!--l. 329--><p class="nopar" >
<!--l. 331--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.3    </span> <a 
 id="x131-31800016.12.3"></a>Differential equations in even and odd variables</h4>
<!--l. 334--><p class="noindent" >We now give the equation in the form of one or more derivatives equated to right-hand side
expressions. The left-hand side derivatives are called <span 
class="ptmri8t-x-x-109">principal</span>, and the remaining derivatives are
called <span 
class="ptmri8t-x-x-109">parametric</span><span class="footnote-mark"><a 
href="manual132.html#fn8x16"><sup class="textsuperscript">8</sup></a></span><a 
 id="x131-318001f8"></a> .
Parametric coordinates are coordinates on the equation manifold and its differential
consequences, and principal coordinates are determined by the differential equation and
its differential consequences. For scalar evolutionary equations with two independent
variables parametric derivatives are of the type <span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">u,u</span><sub><span 
class="cmmi-8">x</span></sub><span 
class="cmmi-10x-x-109">,u</span><sub><span 
class="cmmi-8">xx</span></sub><span 
class="cmmi-10x-x-109">,</span><span 
class="cmmi-10x-x-109">&#x2026;</span><span 
class="cmr-10x-x-109">)</span>. Note that the system must
be in passive orthonomic form; this also means that there will be no nontrivial
integrability conditions between parametric derivatives. (Lines beginning with <span 
class="pcrr8t-x-x-109">% </span>are
comments for REDUCE.) The input is formed as follows (Burger&#8217;s equation).
<a 
 id="dx131-318002"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-620">
%&#x00A0;left-hand&#x00A0;side&#x00A0;of&#x00A0;the&#x00A0;differential&#x00A0;equation
&#x00A0;<br />principal_der:={u_t}$
&#x00A0;<br />%&#x00A0;right-hand&#x00A0;side&#x00A0;of&#x00A0;the&#x00A0;differential&#x00A0;equation
&#x00A0;<br />de:={u_2x+2*u*u_x}$
</div>
<!--l. 353--><p class="nopar" > Systems of PDEs are input in the same way: of course, the above two lists must have the
same length. See <a 
href="#x131-33200016.12.16">16.12.16<!--tex4ht:ref: cdesec:comp-syst-pdes --></a> for an example.
<!--l. 357--><p class="noindent" >The main routine in <span 
class="pcrr8t-x-x-109">cde.red </span>is called as follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-621">
cde({indep_var,dep_var,{},total_order},
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{principal_der,de,{},{}})$
</div>
<!--l. 361--><p class="nopar" > <a 
 id="dx131-318003"></a> <a 
 id="dx131-318004"></a> <a 
 id="dx131-318005"></a> <a 
 id="dx131-318006"></a> Here the three empty lists are placeholders; they are important for computations with
odd variables. The function <span 
class="pcrr8t-x-x-109">cde </span>computes principal and parametric derivatives of
even and odd variables, they are stored in the lists <span 
class="pcrr8t-x-x-109">all_parametric_der,</span>
<span 
class="pcrr8t-x-x-109">all_principal_der, all_parametric_odd, all_principal_odd</span>.
<!--l. 372--><p class="noindent" >The function <span 
class="pcrr8t-x-x-109">cde </span>also defines total derivatives truncated at the order <span 
class="pcrr8t-x-x-109">total_order</span>
and restricted on the (even and odd) equation; this means that total derivatives
are tangent to the equation manifold. Their coordinate expressions are of the
form
<table 
class="equation"><tr><td><a 
 id="x131-318007r48"></a>
<center class="math-display" >
<img 
src="manual109x.png" alt="               &#x2211;                  &#x2211;
D&#x03BB; =  -&#x2202;--+          ui&#x03C3; &#x03BB;-&#x2202;--+           pi&#x03C3;&#x03BB;-&#x2202;--,
      &#x2202;x&#x03BB;   ui&#x03C3; parametric   &#x2202;ui&#x03C3;   pi&#x03C3; parametric   &#x2202;pi&#x03C3;
" class="math-display" ></center></td><td class="equation-label">(16.48)</td></tr></table>
<!--l. 381--><p class="nopar" >
where <span 
class="cmmib-10x-x-109">&#x03C3;</span> is a multiindex. It can happen that <span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmib-8">&#x03C3;</span><span 
class="cmmi-8">&#x03BB;</span></sub><sup><span 
class="cmmi-8">i</span></sup> (or <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmib-8">&#x03C3;</span><span 
class="cmmi-8">&#x03BB;</span></sub><sup><span 
class="cmmi-8">i</span></sup>) is principal and must be
replaced with differential consequences of the equation. Such differential consequences
are called <span 
class="ptmri8t-x-x-109">primary differential consequences</span>, and are computed; in general they
will depend on other, possibly new, differential consequences, and so on. Such
newly appearing differential consequences are called <span 
class="ptmri8t-x-x-109">secondary differential</span>
<span 
class="ptmri8t-x-x-109">consequences</span>. If the equation is in passive orthonomic form, the system of all
differential consequences (up to the maximal order <span 
class="pcrr8t-x-x-109">total_order</span>) must be
solvable in terms of parametric derivatives only. The function <span 
class="ptmri8t-x-x-109">cde </span>automatically
computes all necessary and sufficient differential consequences which are needed
to solve the system. The solved system is available in the form of REDUCE
let-rules in the variables <span 
class="pcrr8t-x-x-109">repprincparam_der </span>and <span 
class="pcrr8t-x-x-109">repprincparam_odd</span>.
<a 
 id="dx131-318008"></a> <a 
 id="dx131-318009"></a>
                                                                     

                                                                     
<!--l. 399--><p class="noindent" >The syntax and properties (expansion and <span 
class="pcrr8t-x-x-109">letop</span>) of total derivatives remain the same.
For exmaple:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-622">
td(u,t);
</div>
<!--l. 403--><p class="nopar" > returns
                                                                     

                                                                     
<div class="verbatim" id="verbatim-623">
u_2x+2*u*u_x;
</div>
<!--l. 407--><p class="nopar" >
<!--l. 409--><p class="noindent" >It is possible to deal with mixed systems on eve and odd variables. For example, in the
case of Burgers equation we can input the linearized equation as a PDE on a
new odd variable as follows (of course, in addition to what has been defined
before):
                                                                     

                                                                     
<div class="verbatim" id="verbatim-624">
odd_var:={q}$
&#x00A0;<br />principal_odd:={q_t}$
&#x00A0;<br />de_odd:={q_2x&#x00A0;+&#x00A0;2*u_x*q&#x00A0;+&#x00A0;2*u*q_x}$
</div>
<!--l. 417--><p class="nopar" > The main routine in <span 
class="pcrr8t-x-x-109">cde.red </span>is called as follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-625">
cde({indep_var,dep_var,odd_var,total_order},
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{principal_der,de,principal_odd,de_odd})$
</div>
<!--l. 422--><p class="nopar" >
<h4 class="subsectionHead"><span class="titlemark">16.12.4    </span> <a 
 id="x131-31900016.12.4"></a>Calculus of variations</h4>
<!--l. 427--><p class="noindent" >CDE can compute variational derivatives of any function (usually a Lagrangian density)
or superfunction <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-4c.png" alt="L" class="10-109x-x-4c" /></span>. We have the following coordinate expression
<table 
class="equation"><tr><td><a 
 id="x131-319001r49"></a>
<center class="math-display" >
<img 
src="manual110x.png" alt="&#x03B4;L             &#x2202;L     &#x03B4;L             &#x2202;L
--i = (- 1)|&#x03C3;|D &#x03C3;--i-,  --i = (- 1)|&#x03C3;|D &#x03C3;--i-
&#x03B4;u             &#x2202;u&#x03C3;    &#x03B4;p             &#x2202;p&#x03C3;
" class="math-display" ></center></td><td class="equation-label">(16.49)</td></tr></table>
<!--l. 435--><p class="nopar" >
which translates into the CDE commands
                                                                     

                                                                     
<div class="verbatim" id="verbatim-626">
pvar_df(0,lagrangian_dens,ui);
&#x00A0;<br />pvar_df(1,lagrangian_dens,pi);
</div>
<!--l. 440--><p class="nopar" > where<a 
 id="dx131-319002"></a>
     <ul class="itemize1">
     <li class="itemize">the first argument can be <span 
class="cmr-10x-x-109">0 </span>or <span 
class="cmr-10x-x-109">1 </span>and is the parity of the variable <span 
class="pcrr8t-x-x-109">ui </span>or <span 
class="pcrr8t-x-x-109">pi</span>;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">lagrangian_dens </span>is <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-4c.png" alt="L" class="10-109x-x-4c" /></span>;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">ui </span>or <span 
class="pcrr8t-x-x-109">pi </span>are the given dependent variables.</li></ul>
<!--l. 448--><p class="noindent" >The Euler operator computes variational derivatives with respect to all even and odd
variables in the jet space, and arranges them in a list of two lists, the list of even
variational derivatives and the list of odd variational derivatives. The command
is<a 
 id="dx131-319003"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-627">
euler_df(lagrangian_dens);
</div>
<!--l. 454--><p class="nopar" > All the above is used in the definition of Schouten brackets, as we will see in
Subsection&#x00A0;<a 
href="#x131-32200016.12.6">16.12.6<!--tex4ht:ref: cdesec:mathc-diff-oper-odd --></a>.
<!--l. 458--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.5    </span> <a 
 id="x131-32000016.12.5"></a><span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators</h4>
<!--l. 461--><p class="noindent" >Linearizing (or taking the Fréchet derivative) of a vector function that defines a
differential equation yields a differential operator in total derivatives. This operator can
be restricted to the differential equation, which may be regarded as a differential
constraint; the kernel of the restricted operator is the space of all symmetries (including
higher or generalized symmetries) <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 468--><p class="noindent" >The formal adjoint of the linearization operator yields by restriction to the corresponding
differential equation a differential operator whose kernel contains all characteristic
vectors or generating functions of conservation laws <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 473--><p class="noindent" >Such operators are examples of <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators. The (still incomplete) REDUCE
implementation of the calculus of <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators is the subject of this
section.
<!--l. 477--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x131-32100016.12.5"></a><span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators</h5>
<!--l. 480--><p class="noindent" >Let us consider the spaces
<center class="math-display" >
<img 
src="manual111x.png" alt="          r          k                r          s
P =  {&#x03C6;: J (n,m ) &#x2192; &#x211D; },    Q  = {&#x03C8;: J (n,m ) &#x2192; &#x211D; }.
" class="math-display" ></center>
<!--l. 483--><p class="nopar" >
A <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span><span 
class="ptmri8t-x-x-109">-differential operator </span><span 
class="cmr-10x-x-109">&#x0394;</span><span 
class="cmr-10x-x-109">:</span> <span 
class="cmmi-10x-x-109">P </span><span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="cmmi-10x-x-109">Q </span>is defined to be a map of the type
<table 
class="equation"><tr><td><a 
 id="x131-321001r50"></a>
                                                                     

                                                                     
<center class="math-display" >
<img 
src="manual112x.png" alt="        &#x2211;   &#x03C3;j
&#x0394;(&#x03C6; ) = (  ai D &#x03C3;&#x03C6;i),
         &#x03C3;,i
" class="math-display" ></center></td><td class="equation-label">(16.50)</td></tr></table>
<!--l. 488--><p class="nopar" >
where <span 
class="cmmi-10x-x-109">a</span><sub><span 
class="cmmi-8">i</span></sub><sup><span 
class="cmmi-8">&#x03C3;j</span></sup> are differentiable functions on <span 
class="cmmi-10x-x-109">J</span><sup><span 
class="cmmi-8">r</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">n,m</span><span 
class="cmr-10x-x-109">)</span>, <span 
class="cmr-10x-x-109">1 </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">i </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">k</span>, <span 
class="cmr-10x-x-109">1 </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">j </span><span 
class="cmsy-10x-x-109">&#x2264; </span><span 
class="cmmi-10x-x-109">s</span>. The <span 
class="ptmri8t-x-x-109">order </span>of
<span 
class="cmmi-10x-x-109">&#x03B4; </span>is the highest length of <span 
class="cmmi-10x-x-109">&#x03C3; </span>in the above formula.
<!--l. 493--><p class="noindent" >We may consider a generalization to <span 
class="cmmi-10x-x-109">k</span>-<span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span><span 
class="ptmri8t-x-x-109">-differential operators </span>of the type <table 
class="multline"><tr><td><img 
src="manual113x.png" alt="&#x0394; : P1 &#x00D7; &#x22C5;&#x22C5;&#x22C5;&#x00D7; Ph &#x2192; Q           &#x2211;
          &#x0394; (&#x03C6;1,...,&#x03C6;h) = (           a&#x03C3;1,...,&#x03C3;h, jD &#x03C3; &#x03C6;i1 &#x22C5;&#x22C5;&#x22C5;D &#x03C3; &#x03C6;ih),
                           &#x03C3;1,...,&#x03C3;,i1,...,i  i1&#x22C5;&#x22C5;&#x22C5;ih      1 1      h h
                               h     h
" ><a 
 id="x131-321002r51"></a></td><td class="equation-label"><br />(16.51)<br /></td></tr></table>where the enclosing parentheses mean that the value of the operator is a vector
function in <span 
class="cmmi-10x-x-109">Q</span>.
<!--l. 505--><p class="noindent" >A <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator in CDE must be declared as follows: <a 
 id="dx131-321003"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-628">
mk_cdiffop(opname,num_arg,length_arg,length_target)
</div>
<!--l. 509--><p class="nopar" > where
     <ul class="itemize1">
     <li class="itemize"><span 
class="pcrr8t-x-x-109">opname </span>is the name of the operator;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">num_arg </span>is the number of arguments <span 
class="ptmri8t-x-x-109">eg </span><span 
class="cmmi-10x-x-109">k </span>in (<a 
href="#x131-321002r51">16.51<!--tex4ht:ref: eq:7 --></a>);
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">length_arg </span>is the list of lengths of the arguments: <span 
class="ptmri8t-x-x-109">eg </span>the length of the
     single argument of <span 
class="cmr-10x-x-109">&#x0394;</span> (<a 
href="#x131-321001r50">16.50<!--tex4ht:ref: eq:4 --></a>) is <span 
class="cmmi-10x-x-109">k</span>, and the corresponding list is <span 
class="pcrr8t-x-x-109">{k}</span>, while
     in (<a 
href="#x131-321002r51">16.51<!--tex4ht:ref: eq:7 --></a>) one needs a list of <span 
class="cmmi-10x-x-109">k </span>items <span 
class="pcrr8t-x-x-109">{k_1,</span><span 
class="pcrr8t-x-x-109">&#x2026;,k_h}</span>, each corresponding
     to number of components of the vector functions to which the operator is
     applied;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">length_target </span>is the numer of components of the image vector function.</li></ul>
<!--l. 523--><p class="noindent" >The syntax for one component of the operator <span 
class="pcrr8t-x-x-109">opname </span>is
                                                                     

                                                                     
<div class="verbatim" id="verbatim-629">
&#x00A0;&#x00A0;opname(j,i1,...,ih,phi1,...,phih)
</div>
<!--l. 526--><p class="nopar" > The above operator will compute
<table 
class="equation"><tr><td><a 
 id="x131-321004r52"></a>
<center class="math-display" >
<img 
src="manual114x.png" alt="&#x0394;(&#x03C6; ,...,&#x03C6; ) =  &#x2211;    a&#x03C3;1,...,&#x03C3;h, jD &#x03C6;i1 &#x22C5;&#x22C5;&#x22C5;D   &#x03C6;ih,
   1      h    &#x03C3; ,...,&#x03C3;  i1&#x22C5;&#x22C5;&#x22C5;ih     &#x03C3;1 1     &#x03C3;h h
                1   h
" class="math-display" ></center></td><td class="equation-label">(16.52)</td></tr></table>
<!--l. 533--><p class="nopar" >
for fixed integer indices <span 
class="cmmi-10x-x-109">i</span><sub><span 
class="cmr-8">1</span></sub>,&#x2026;,<span 
class="cmmi-10x-x-109">i</span><sub><span 
class="cmmi-8">h</span></sub> and <span 
class="cmmi-10x-x-109">j</span>.
<!--l. 538--><p class="noindent" >There are several operations which involve differential operators. Obviously they can be
summed and multiplied by scalars.
<!--l. 541--><p class="noindent" >An important example of <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator is that of <span 
class="ptmri8t-x-x-109">linearization</span>, or <span 
class="ptmri8t-x-x-109">Fr</span><span 
class="ptmri8t-x-x-109">échet</span>
<span 
class="ptmri8t-x-x-109">derivative</span>, of a vector function
<center class="math-display" >
<img 
src="manual115x.png" alt="F : Jr(n,m ) &#x2192; &#x211D;k.
" class="math-display" ></center>
<!--l. 545--><p class="nopar" >
This is the operator
<center class="math-display" >
<img 
src="manual116x.png" alt="                 &#x2211;      k
&#x2113;F : &#x03F0; &#x2192; P,  &#x03C6; &#x21A6;&#x2192;     &#x2202;F--D &#x03C3;&#x03C6;i,
                  &#x03C3;,i &#x2202;ui&#x03C3;
" class="math-display" ></center>
<!--l. 550--><p class="nopar" >
                                                                     

                                                                     
where <span 
class="msbm-10x-x-109">&#x03F0; </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmsy-10x-x-109">{</span><span 
class="cmmi-10x-x-109">&#x03C6;</span><span 
class="cmr-10x-x-109">:</span> <span 
class="cmmi-10x-x-109">J</span><sup><span 
class="cmmi-8">r</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">n,m</span><span 
class="cmr-10x-x-109">) </span><span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">m</span></sup><span 
class="cmsy-10x-x-109">} </span>is the space of <span 
class="ptmri8t-x-x-109">generalized vector fields on jets</span>
<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 554--><p class="noindent" >Linearization can be extended to an operation that, starting from a <span 
class="cmmi-10x-x-109">k</span>-<span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential
operator, generates a <span 
class="cmmi-10x-x-109">k </span><span 
class="cmr-10x-x-109">+ 1</span>-<span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator as follows:
<center class="math-display" >
<img 
src="manual117x.png" alt="                                   &#x03C3;1,...,&#x03C3;k, j
&#x2113;  (p ,...,p ,&#x03C6;) = (     &#x2211;        &#x2202;ai1&#x22C5;&#x22C5;&#x22C5;ik----D  &#x03C6;iD  pi1&#x22C5;&#x22C5;&#x22C5;D   pik)
 &#x0394;  1      k                        &#x2202;ui&#x03C3;      &#x03C3;   &#x03C3;1 1      &#x03C3;k k
                   &#x03C3;,&#x03C3;1,...,&#x03C3;k,i,i1,...,ik
" class="math-display" ></center>
<!--l. 563--><p class="nopar" >
(The above operation is also denoted by <span 
class="cmmi-10x-x-109">&#x2113;</span><sub><span 
class="cmr-8">&#x0394;</span><span 
class="cmmi-8">,p</span><sub><span 
class="cmr-6">1</span></sub><span 
class="cmmi-8">,</span><span 
class="cmmi-8">&#x2026;</span><span 
class="cmmi-8">,p</span><sub><span 
class="cmmi-6">k</span></sub></sub><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">&#x03C6;</span><span 
class="cmr-10x-x-109">)</span>.)
<!--l. 566--><p class="noindent" >At the moment, CDE is only able to compute the linearization of a vector function
(Section&#x00A0;<a 
href="#x131-32400016.12.8">16.12.8<!--tex4ht:ref: cdesec:linadj --></a>).
<!--l. 569--><p class="noindent" >Given a <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator <span 
class="cmr-10x-x-109">&#x0394; </span>like in (<a 
href="#x131-321001r50">16.50<!--tex4ht:ref: eq:4 --></a>) we can define its <span 
class="ptmri8t-x-x-109">adjoint </span>as
<table 
class="equation"><tr><td><a 
 id="x131-321005r53"></a>
<center class="math-display" >
<img 
src="manual118x.png" alt="&#x0394;*((q )) = (&#x2211;  (- 1)|&#x03C3;|D (a&#x03C3;jq)).
     j                &#x03C3;  i  j
           &#x03C3;,i
" class="math-display" ></center></td><td class="equation-label">(16.53)</td></tr></table>
<!--l. 574--><p class="nopar" >
Note that the matrix of coefficients is transposed. Again, the coefficients of the adjoint
operator can be found by computing <span 
class="cmr-10x-x-109">&#x0394;</span><sup><span 
class="cmsy-8">*</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">x</span><sup><span 
class="cmmi-8">&#x03C3;</span></sup><span 
class="cmmi-10x-x-109">e</span><sub><span 
class="cmmi-8">j</span></sub><span 
class="cmr-10x-x-109">) </span>for every basis vector <span 
class="cmmi-10x-x-109">e</span><sub><span 
class="cmmi-8">j</span></sub> and every count
<span 
class="cmmi-10x-x-109">x</span><sup><span 
class="cmmi-8">&#x03C3;</span></sup>, where <span 
class="cmsy-10x-x-109">|</span><span 
class="cmmi-10x-x-109">&#x03C3;</span><span 
class="cmsy-10x-x-109">|&#x2264; </span><span 
class="cmmi-10x-x-109">r</span>, and <span 
class="cmmi-10x-x-109">r </span>is the order of the operator. This operation can be generalized to
<span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators with <span 
class="cmmi-10x-x-109">h </span>arguments.
<!--l. 581--><p class="noindent" >At the moment, CDE can compute the adjoint of an operator with one argument
(Section&#x00A0;<a 
href="#x131-32400016.12.8">16.12.8<!--tex4ht:ref: cdesec:linadj --></a>).
<!--l. 584--><p class="noindent" >Now, consider two operators <span 
class="cmr-10x-x-109">&#x0394;</span><span 
class="cmr-10x-x-109">:</span> <span 
class="cmmi-10x-x-109">P </span><span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="cmmi-10x-x-109">Q </span>and <span 
class="cmsy-10x-x-109">&#x2207;</span><span 
class="cmr-10x-x-109">:</span> <span 
class="cmmi-10x-x-109">Q </span><span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="cmmi-10x-x-109">R</span>. Then the composition <span 
class="cmsy-10x-x-109">&#x2207;&#x2218; </span><span 
class="cmr-10x-x-109">&#x0394;</span>
is again a <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator. In particular, if
<center class="math-display" >
<img 
src="manual119x.png" alt="        &#x2211;   &#x03C3;j    i           &#x2211;    &#x03C4;k    j
&#x0394;(p) = (   ai D &#x03C3;p ),  &#x2207; (q) = (   bj D &#x03C4;q ),
        &#x03C3;,i                    &#x03C4;,j
" class="math-display" ></center>
<!--l. 590--><p class="nopar" >
then
<center class="math-display" >
<img 
src="manual120x.png" alt="            &#x2211;         &#x2211;
&#x2207; &#x2218; &#x0394; (p) = (   b&#x03C4;kD &#x03C4;(   a&#x03C3;jD &#x03C3;pi))
            &#x03C4;,j j     &#x03C3;,i  i
" class="math-display" ></center>
<!--l. 595--><p class="nopar" >
This operation can be generalized to <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators with <span 
class="cmmi-10x-x-109">h </span>arguments.
<!--l. 599--><p class="noindent" >There is another important operation between <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators with <span 
class="cmmi-10x-x-109">h </span>arguments:
the <span 
class="ptmri8t-x-x-109">Schouten bracket </span><span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. We will discuss it in next Subsection, in the context of another
formalism, where it takes an easier form <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 603--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.6    </span> <a 
 id="x131-32200016.12.6"></a><span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators as superfunctions</h4>
<!--l. 606--><p class="noindent" >In the papers <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span> (and independently in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>) a scheme for dealing with (skew-adjoint)
variational multivectors was devised. The idea was that operators of the type (<a 
href="#x131-321002r51">16.51<!--tex4ht:ref: eq:7 --></a>)
could be represented by homogeneous vector superfunctions on a supermanifold, where
odd coordinates <span 
class="cmmi-10x-x-109">q</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><sup><span 
class="cmmi-8">i</span></sup> would correspond to total derivatives <span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><span 
class="cmmi-10x-x-109">&#x03C6;</span><sup><span 
class="cmmi-8">i</span></sup>.
<!--l. 612--><p class="noindent" >The isomorphism between the two languages is given by
<table 
class="equation"><tr><td><a 
 id="x131-322001r54"></a>
<center class="math-display" >
<img 
src="manual121x.png" alt="(     &#x2211;                               )
              a&#x03C3;i11,&#x22C5;..&#x22C5;&#x22C5;i.,h&#x03C3;h, jD &#x03C3;1&#x03C6;i11&#x22C5;&#x22C5;&#x22C5;D &#x03C3;h&#x03C6;ihh
  &#x03C3;1,...,&#x03C3;h,i1,...,ih
        (    &#x2211;        &#x03C3;1,...,&#x03C3;h, j i    i)
    -&#x2192;               ai1&#x22C5;&#x22C5;&#x22C5;ih    q1&#x03C3;1 &#x22C5;&#x22C5;&#x22C5;qh&#x03C3;h
         &#x03C3;1,...,&#x03C3;h,i1,...,ih
" class="math-display" ></center></td><td class="equation-label">(16.54)</td></tr></table>
<!--l. 625--><p class="nopar" >
where <span 
class="cmmi-10x-x-109">q</span><sub><span 
class="cmmi-8">&#x03C3;</span></sub><sup><span 
class="cmmi-8">i</span></sup> is the derivative of an odd dependent variable (and an odd variable
itself).
<!--l. 629--><p class="noindent" >A superfunction in CDE must be declared as follows: <a 
 id="dx131-322002"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-630">
mk_superfun(sfname,num_arg,length_arg,length_target)
</div>
<!--l. 633--><p class="nopar" > where
     <ul class="itemize1">
     <li class="itemize"><span 
class="pcrr8t-x-x-109">sfname </span>is the name of the superfunction;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">num_arg </span>is the degree of the superfunction <span 
class="ptmri8t-x-x-109">eg </span><span 
class="cmmi-10x-x-109">h </span>in (<a 
href="#x131-322001r54">16.54<!--tex4ht:ref: eq:13 --></a>);
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">length_arg </span>is the list of lengths of the arguments: <span 
class="ptmri8t-x-x-109">eg </span>the length of the
     single argument of <span 
class="cmr-10x-x-109">&#x0394;</span> (<a 
href="#x131-321001r50">16.50<!--tex4ht:ref: eq:4 --></a>) is <span 
class="cmmi-10x-x-109">k</span>, and the corresponding list is <span 
class="pcrr8t-x-x-109">{k}</span>, while
     in (<a 
href="#x131-321002r51">16.51<!--tex4ht:ref: eq:7 --></a>) one needs a list of <span 
class="cmmi-10x-x-109">k </span>items <span 
class="pcrr8t-x-x-109">{k_1,</span><span 
class="pcrr8t-x-x-109">&#x2026;,k_h}</span>, each corresponding
     to number of components of the vector functions to which the operator is
     applied;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">length_target </span>is the numer of components of the image vector function.</li></ul>
<!--l. 647--><p class="noindent" >The above parameters of the operator <span 
class="pcrr8t-x-x-109">opname </span>are stored in the property
list<span class="footnote-mark"><a 
href="manual133.html#fn9x16"><sup class="textsuperscript">9</sup></a></span><a 
 id="x131-322003f9"></a>  of
the identifier <span 
class="pcrr8t-x-x-109">opname</span>. This means that if one would like to know how many arguments
has the operator <span 
class="pcrr8t-x-x-109">opname </span>the answer will be the output of the command
                                                                     

                                                                     
<div class="verbatim" id="verbatim-631">
get(&#8217;cdnarg,cdiff_op);
</div>
<!--l. 654--><p class="nopar" > and the same for the other parameters.
<!--l. 657--><p class="noindent" >The syntax for one component of the superfunction <span 
class="pcrr8t-x-x-109">sfname </span>is
                                                                     

                                                                     
<div class="verbatim" id="verbatim-632">
&#x00A0;&#x00A0;sfname(j)
</div>
<!--l. 660--><p class="nopar" >
<!--l. 662--><p class="noindent" >CDE is able to deal with <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators in both formalisms, and provides
conversion utilities: <a 
 id="dx131-322004"></a> <a 
 id="dx131-322005"></a>
     <ul class="itemize1">
     <li class="itemize"><span 
class="pcrr8t-x-x-109">conv_cdiff2superfun(cdop,superfun)</span>
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">conv_superfun2cdiff(superfun,cdop)</span></li></ul>
<!--l. 670--><p class="noindent" >where in the first case a <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator <span 
class="pcrr8t-x-x-109">cdop </span>is converted into a vector
superfunction <span 
class="pcrr8t-x-x-109">superfun </span>with the same properties, and conversely.
<h4 class="subsectionHead"><span class="titlemark">16.12.7    </span> <a 
 id="x131-32300016.12.7"></a>The Schouten bracket</h4>
<!--l. 677--><p class="noindent" >We are interested in the operation of Schouten bracket between <span 
class="ptmri8t-x-x-109">variational multivectors</span>
<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. These are differential operators with <span 
class="cmmi-10x-x-109">h </span>arguments in <span 
class="msbm-10x-x-109">&#x03F0; </span>with values in densities, and
whose image is defined up to total divergencies: <table 
class="multline"><tr><td><img 
src="manual122x.png" alt="&#x0394; : &#x03F0; &#x00D7; &#x22C5;&#x22C5;&#x22C5;&#x00D7; &#x03F0; &#x2192;
                 {J r(n, m) &#x2192; &#x03BB;nT *&#x211D; &#x22C9;}&#x2215;¯d({Jr(n,m ) &#x2192; &#x03BB;n-1T *&#x211D;&#x22C9; })
" ><a 
 id="x131-323001r55"></a></td><td class="equation-label"><br />(16.55)<br /></td></tr></table>It is known <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span> that the Schouten bracket between two variational multivectors
<span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">1</span></sub>, <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">2</span></sub> can be computed in terms of their corresponding superfunction by the
formula
<table 
class="equation"><tr><td><a 
 id="x131-323002r56"></a>
<center class="math-display" >
                                                                     

                                                                     
<img 
src="manual123x.png" alt="          [&#x03B4;A1 &#x03B4;A2   &#x03B4;A2 &#x03B4;A1 ]
[A1,A2] =  &#x03B4;uj-&#x03B4;p--+ -&#x03B4;uj-&#x03B4;p-
                 j          j
" class="math-display" ></center></td><td class="equation-label">(16.56)</td></tr></table>
<!--l. 693--><p class="nopar" >
where <span 
class="cmmi-10x-x-109">&#x03B4;&#x2215;&#x03B4;u</span><span 
class="cmmi-8">i</span>, <span 
class="cmmi-10x-x-109">&#x03B4;&#x2215;&#x03B4;p</span><span 
class="cmmi-8">j</span> are the variational derivatives and the square brackets at
the right-hand side should be understood as the equivalence class up to total
divergencies.
<!--l. 698--><p class="noindent" >If the operators <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">1</span></sub>, <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">2</span></sub> are compatible, <span 
class="ptmri8t-x-x-109">ie </span><span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">1</span></sub><span 
class="cmmi-10x-x-109">,A</span><sub><span 
class="cmr-8">2</span></sub><span 
class="cmr-10x-x-109">] = 0</span>, the expression&#x00A0;(<a 
href="#x131-323002r56">16.56<!--tex4ht:ref: eq:11 --></a>) must be a
total derivative. This means that:
<table 
class="equation"><tr><td><a 
 id="x131-323003r57"></a>
<center class="math-display" >
<img 
src="manual124x.png" alt="                    (                   )
                      &#x03B4;A1-&#x03B4;A2-  &#x03B4;A2-&#x03B4;A1-
[A1,A2 ] = 0  &#x21D4;   E   &#x03B4;uj &#x03B4;pj +  &#x03B4;uj &#x03B4;pj  = 0.
" class="math-display" ></center></td><td class="equation-label">(16.57)</td></tr></table>
<!--l. 705--><p class="nopar" >
<!--l. 707--><p class="noindent" >If <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">1</span></sub> is an <span 
class="cmmi-10x-x-109">h</span>-vector and <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">2</span></sub> is a <span 
class="cmmi-10x-x-109">k</span>-vector the formula&#x00A0;(<a 
href="#x131-323002r56">16.56<!--tex4ht:ref: eq:11 --></a>) produces a <span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">h </span><span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">k </span><span 
class="cmsy-10x-x-109">- </span><span 
class="cmr-10x-x-109">1)</span>-vector,
or a <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator with <span 
class="cmmi-10x-x-109">h </span><span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">k </span><span 
class="cmsy-10x-x-109">- </span><span 
class="cmr-10x-x-109">1 </span>arguments. If we would like to check
that this multivector is indeed a total divergence, we should apply the Euler
operator, and check that it is zero. This procedure is considerably simpler than the
analogue formula with operators (see for example <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>). All this is computed by
CDE:<a 
 id="dx131-323004"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-633">
schouten_bracket(biv1,biv2,tv12),
</div>
<!--l. 716--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">biv1 </span>and <span 
class="pcrr8t-x-x-109">biv2 </span>are bivectors, or <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operators with <span 
class="cmr-10x-x-109">2 </span>arguments, and
<span 
class="pcrr8t-x-x-109">tv12 </span>is the result of the computation, which is a three-vector (it is automatically
declared to be a superfunction). Examples of this computation are given in
Section&#x00A0;<a 
href="#x131-33400016.12.18">16.12.18<!--tex4ht:ref: cdesec:scho-brack-local --></a>.
<!--l. 722--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.8    </span> <a 
 id="x131-32400016.12.8"></a>Computing linearization and its adjoint</h4>
<!--l. 725--><p class="noindent" >Currently, CDE supports linearization of a vector function, or a <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator
with <span 
class="cmr-10x-x-109">0 </span>arguments. The computation is performed in odd coordinates.
<!--l. 728--><p class="noindent" >Suppose that we would like to linearize the vector function that defines the
(dispersionless) Boussinesq equation <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>:
<table 
class="equation"><tr><td><a 
 id="x131-324001r58"></a>
<center class="math-display" >
<img 
src="manual125x.png" alt="{ ut - uxv - uvx - &#x03C3;vxxx = 0
  v - u  - vv  = 0
   t    x    x
" class="math-display" ></center></td><td class="equation-label">(16.58)</td></tr></table>
<!--l. 738--><p class="nopar" >
where <span 
class="cmmi-10x-x-109">&#x03C3; </span>is a constant. Then a jet space with independent variables <span 
class="pcrr8t-x-x-109">x,t</span>, dependent
variables <span 
class="pcrr8t-x-x-109">u,v </span>and odd variables <span 
class="ptmri8t-x-x-109">in the same number as dependent variables </span><span 
class="pcrr8t-x-x-109">p,q </span>must
be created:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-634">
indep_var:={x,t}$
&#x00A0;<br />dep_var:={u,v}$
&#x00A0;<br />odd_var:={p,q}$
&#x00A0;<br />total_order:=8$
&#x00A0;<br />cde({indep_var,dep_var,odd_var,total_order},{})$
</div>
<!--l. 748--><p class="nopar" > The linearization of the above system and its adjoint are, respectively
<table 
class="align-star">
            <tr><td 
class="align-odd"><span 
class="cmmi-10x-x-109">&#x2113;</span><sub>Bou</sub></td>             <td 
class="align-even"> <span 
class="cmr-10x-x-109">= </span><img 
src="manual126x.png" alt="(D   - vD  - v   - u - uD   - &#x03C3;D    )
   t     x    x     x     x      xxx
      - Dx          Dt - vx - vDx"  class="left" align="middle"><span 
class="cmmi-10x-x-109">,</span></td>            <td 
class="align-label"></td>            <td 
class="align-label">
            </td></tr><tr><td 
class="align-odd"><span 
class="cmmi-10x-x-109">&#x2113;</span><sub>Bou</sub><sup><span 
class="cmsy-8">*</span></sup></td>            <td 
class="align-even"> <span 
class="cmr-10x-x-109">= </span><img 
src="manual127x.png" alt="(                         )
   - Dt + vDx       Dx
  uDx + &#x03C3;Dxxx   - Dt + vDx"  class="left" align="middle"></td>                      <td 
class="align-label"></td>            <td 
class="align-label"></td></tr></table>
<!--l. 762--><p class="noindent" >Let us introduces the vector function whose zeros are the Boussinesq equation:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-635">
f_bou:={u_t&#x00A0;-&#x00A0;(u_x*v&#x00A0;+&#x00A0;u*v_x&#x00A0;+&#x00A0;sig*v_3x),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;v_t&#x00A0;-&#x00A0;(u_x&#x00A0;+&#x00A0;v*v_x)};
</div>
<!--l. 766--><p class="nopar" > The following command assigns to the identifier <span 
class="pcrr8t-x-x-109">lbou </span>the linearization <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential
operator <span 
class="cmmi-10x-x-109">&#x2113;</span><sub>Bou</sub> of the vector function <span 
class="pcrr8t-x-x-109">f_bou</span><a 
 id="dx131-324002"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-636">
ell_function(f_bou,lbou);
</div>
<!--l. 772--><p class="nopar" > moreover, a superfunction <span 
class="pcrr8t-x-x-109">lbou_sf </span>is also defined as the vector superfunction
corresponding to <span 
class="cmmi-10x-x-109">&#x2113;</span><sub>Bou</sub>. Indeed, the following sequence of commands:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-637">
2:&#x00A0;lbou_sf(1);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;-&#x00A0;p*v_x&#x00A0;+&#x00A0;p_t&#x00A0;-&#x00A0;p_x*v&#x00A0;-&#x00A0;q*u_x&#x00A0;-&#x00A0;q_3x*sig&#x00A0;-&#x00A0;q_x*u
&#x00A0;<br />
&#x00A0;<br />3:&#x00A0;lbou_sf(2);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;-&#x00A0;p_x&#x00A0;-&#x00A0;q*v_x&#x00A0;+&#x00A0;q_t&#x00A0;-&#x00A0;q_x*v
</div>
<!--l. 784--><p class="nopar" > shows the vector superfunction corresponding to <span 
class="cmmi-10x-x-109">&#x2113;</span><sub>Bou</sub>. To compute the value of the
<span 
class="cmr-10x-x-109">(1</span><span 
class="cmmi-10x-x-109">,</span><span 
class="cmr-10x-x-109">1) </span>component of the matrix <span 
class="cmmi-10x-x-109">&#x2113;</span><sub>Bou</sub> applied to an argument <span 
class="pcrr8t-x-x-109">psi </span>do
                                                                     

                                                                     
<div class="verbatim" id="verbatim-638">
lbou(1,1,psi);
</div>
<!--l. 790--><p class="nopar" > In order to check that the result is correct one could define the linearization as a
<span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator and then check that the corresponding superfunctions are the
same:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-639">
mk_cdiffop(lbou2,1,{2},2);
&#x00A0;<br />for&#x00A0;all&#x00A0;phi&#x00A0;let&#x00A0;lbou2(1,1,phi)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;td(phi,t)&#x00A0;-&#x00A0;v*td(phi,x)&#x00A0;-&#x00A0;v_x*phi;
&#x00A0;<br />for&#x00A0;all&#x00A0;phi&#x00A0;let&#x00A0;lbou2(1,2,phi)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;-&#x00A0;u_x*phi&#x00A0;-&#x00A0;u*td(phi,x)&#x00A0;-&#x00A0;sig*td(phi,x,3);
&#x00A0;<br />for&#x00A0;all&#x00A0;phi&#x00A0;let&#x00A0;lbou2(2,1,phi)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;-&#x00A0;td(phi,x);
&#x00A0;<br />for&#x00A0;all&#x00A0;phi&#x00A0;let&#x00A0;lbou2(2,2,phi)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;td(phi,t)&#x00A0;-&#x00A0;v*td(phi,x)&#x00A0;-&#x00A0;v_x*phi;
&#x00A0;<br />
&#x00A0;<br />conv_cdiff2superfun(lbou2,lbou2_sf);
&#x00A0;<br />lbou2_sf(1)&#x00A0;-&#x00A0;lbou_sf(1);
&#x00A0;<br />lbou2_sf(2)&#x00A0;-&#x00A0;lbou_sf(2);
</div>
<!--l. 808--><p class="nopar" > the result of the two last commands must be zero.
<!--l. 811--><p class="noindent" >The formal adjoint of <span 
class="pcrr8t-x-x-109">lbou </span>can be computed and assigned to the identifier <span 
class="pcrr8t-x-x-109">lbou_star</span>
by the command <a 
 id="dx131-324003"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-640">
adjoint_cdiffop(lbou,lbou_star);
</div>
<!--l. 816--><p class="nopar" > Again, the associated vector superfunction <span 
class="pcrr8t-x-x-109">lbou_star_sf </span>is computed, with
values
                                                                     

                                                                     
<div class="verbatim" id="verbatim-641">
4:&#x00A0;lbou_star_sf(1);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;-&#x00A0;p_t&#x00A0;+&#x00A0;p_x*v&#x00A0;+&#x00A0;q_x
&#x00A0;<br />
&#x00A0;<br />5:&#x00A0;lbou_star_sf(2);
&#x00A0;<br />
&#x00A0;<br />p_3x*sig&#x00A0;+&#x00A0;p_x*u&#x00A0;-&#x00A0;q_t&#x00A0;+&#x00A0;q_x*v
</div>
<!--l. 827--><p class="nopar" > Again, the above operator can be checked for correctness.
<!--l. 830--><p class="noindent" >Once the linearization and its ajdoint are computed, in order to do computations with
symmetries and conservation laws such operator must be restricted to the corresponding
equation. This can be achieved with the following steps:
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x131-324005x1"><a 
 id="x131-3240041"></a> compute linearization of a PDE of the form <span 
class="cmmi-10x-x-109">F </span><span 
class="cmr-10x-x-109">= 0 </span>and its adjoint, and save
     them in the form of a vector superfunction;
     </li>
     <li 
  class="enumerate" id="x131-324007x2">start a new computation with the given <span 
class="ptmri8t-x-x-109">even </span>PDE as a constraint on the (even)
     jet space;
     </li>
     <li 
  class="enumerate" id="x131-324009x3">load the superfunctions of item <a 
href="#x131-3240041">1<!--tex4ht:ref: first --></a>;
     </li>
     <li 
  class="enumerate" id="x131-324011x4">restrict them to the even PDE.</li></ol>
<!--l. 842--><p class="noindent" >Only the last step needs to be explained. If we are considering, <span 
class="ptmri8t-x-x-109">eg </span>the Boussinesq
equation, then <span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">t</span></sub> and its differential consequences (<span 
class="ptmri8t-x-x-109">ie </span>the principal derivatives) are not
automatically expanded to the right-hand side of the equation and its differential
consequences. At the moment this step is not fully automatic. More precisely, only
principal derivatives which appear as coefficients in total derivatives can be replaced by
their expression. The lists of such derivatives with the corresponding expressions are
<span 
class="pcrr8t-x-x-109">repprincparam_der </span>and <span 
class="pcrr8t-x-x-109">repprincparam_odd </span>(see Section&#x00A0;<a 
href="#x131-31800016.12.3">16.12.3<!--tex4ht:ref: cdesec:diff-equat-even --></a>). They are
in the format of REDUCE&#8217;s replacement list and can be used in let-rules. If the
linearization or its adjoint happen to depend on another principal derivative this must be
computed separately. A forthcoming release of REDUCE will automatize this
procedure.
<!--l. 855--><p class="noindent" >However, note that for evolutionary equations this step is trivial, as the restriction of
linearization and its adjoint on the given PDE will only affect total derivatives which are
                                                                     

                                                                     
restricted by CDE to the PDE.
<!--l. 859--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.9    </span> <a 
 id="x131-32500016.12.9"></a>Higher symmetries</h4>
<!--l. 862--><p class="noindent" >In this section we show the computation of (some) higher <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span> (or generalized, <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>)
symmetries of Burgers&#8217;equation <span 
class="cmmi-10x-x-109">B </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">t</span></sub> <span 
class="cmsy-10x-x-109">- </span><span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">xx</span></sub> <span 
class="cmr-10x-x-109">+ 2</span><span 
class="cmmi-10x-x-109">uu</span><sub><span 
class="cmmi-8">x</span></sub> <span 
class="cmr-10x-x-109">= 0</span>.
<!--l. 865--><p class="noindent" >We provide two ways to solve the equations for higher symmetries. The first possibility is
to use dimensional analysis. The idea is that one can use the scale symmetries of
Burgers&#8217;equation to assign &#8220;gradings&#8221; to each variable appearing in the equation (in
other words, one can use dimensional analisys). As a consequence, one could try
different ansatz for symmetries with polynomial generating functions. For example, it is
possible to require that they are sum of monomials of given degrees. This ansatz yields a
simplification of the equations for symmetries, because it is possible to solve them in a
&#8220;graded&#8221; way, <span 
class="ptmri8t-x-x-109">i.e.</span>, it is possible to split them into several equations made by
the homogeneous components of the equation for symmetries with respect to
gradings.
<!--l. 877--><p class="noindent" >In particular, Burgers&#8217;equation translates into the following dimensional equation:
<center class="math-display" >
<img 
src="manual128x.png" alt="[ut] = [uxx],  [uxx] = [2uux].
" class="math-display" ></center>
<!--l. 881--><p class="nopar" >
By the rules <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">z</span></sub><span 
class="cmr-10x-x-109">] = [</span><span 
class="cmmi-10x-x-109">u</span><span 
class="cmr-10x-x-109">] </span><span 
class="cmsy-10x-x-109">- </span><span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">z</span><span 
class="cmr-10x-x-109">] </span>and <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">uv</span><span 
class="cmr-10x-x-109">] = [</span><span 
class="cmmi-10x-x-109">u</span><span 
class="cmr-10x-x-109">] + [</span><span 
class="cmmi-10x-x-109">v</span><span 
class="cmr-10x-x-109">]</span>, and choosing <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">x</span><span 
class="cmr-10x-x-109">] = </span><span 
class="cmsy-10x-x-109">-</span><span 
class="cmr-10x-x-109">1</span>, we have
<span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">u</span><span 
class="cmr-10x-x-109">] = 1 </span>and <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">t</span><span 
class="cmr-10x-x-109">] = </span><span 
class="cmsy-10x-x-109">-</span><span 
class="cmr-10x-x-109">2</span>. This will be used to generate the list of homogeneous monomials
of given grading to be used in the ansatz about the structure of the generating function of
the symmetries.
<!--l. 887--><p class="noindent" >The file for the above computation is <span 
class="pcrr8t-x-x-109">bur_hsy1.red </span>and the results of the
computation are in <span 
class="pcrr8t-x-x-109">results/bur_hsy1_res.red</span>.
<!--l. 891--><p class="noindent" >Another possibility to solve the equation for higher symmetries is to use a PDE solver
that is especially devoted to overdetermined systems, which is the distinguishing feature
of systems coming from the symmetry analysis of PDEs. This approach is described
below. The file for the above computation is <span 
class="pcrr8t-x-x-109">bur_hsy2.red </span>and the results of the
computation are in <span 
class="pcrr8t-x-x-109">results/bur_hsy2_res.red</span>.
<!--l. 899--><p class="noindent" >
                                                                     

                                                                     
<h4 class="subsectionHead"><span class="titlemark">16.12.10    </span> <a 
 id="x131-32600016.12.10"></a>Setting up the jet space and the differential equation.</h4>
<!--l. 902--><p class="noindent" >After loading CDE:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-642">
indep_var:={x,t}$
&#x00A0;<br />dep_var:={u}$
&#x00A0;<br />deg_indep_var:={-1,-2}$
&#x00A0;<br />deg_dep_var:={1}$
&#x00A0;<br />total_order:=10$
</div>
<!--l. 909--><p class="nopar" > Here the new lists are scale degrees:
     <ul class="itemize1">
     <li class="itemize"><span 
class="pcrr8t-x-x-109">deg_indep_var </span>is the list of scale degrees of the independent variables;
     </li>
     <li class="itemize"><span 
class="pcrr8t-x-x-109">deg_dep_var </span>is the list of scale degrees of the dependent variables;</li></ul>
<!--l. 918--><p class="noindent" >We now give the equation and call CDE:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-643">
principal_der:={u_t}$
&#x00A0;<br />de:={u_2x+2*u*u_x}$
&#x00A0;<br />cde({indep_var,dep_var,{},total_order},
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{principal_der,de,{},{}})$
</div>
<!--l. 924--><p class="nopar" >
<!--l. 926--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.11    </span> <a 
 id="x131-32700016.12.11"></a>Solving the problem via dimensional analysis.</h4>
<!--l. 929--><p class="noindent" >Higher symmetries of the given equation are functions <span 
class="pcrr8t-x-x-109">sym </span>depending on parametric
coordinates up to some jet space order. We assume that they are graded polynomials of
all parametric derivatives. In practice, we generate a linear combination of graded
monomials with arbitrary coefficients, then we plug it in the equation of the problem and
find conditions on the coefficients that fulfill the equation. To construct a good ansatz, it
is required to make several attempts with different gradings, possibly including
independent variables, etc.. For this reason, ansatz-constructing functions are especially
verbose. In order to use such functions they must be initialized with the following
command:<a 
 id="dx131-327001"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-644">
cde_grading(deg_indep_var,deg_dep_var,{})$
</div>
<!--l. 941--><p class="nopar" > Note the empty list at the end; it playe a role only for computations involving odd
variables.
<!--l. 945--><p class="noindent" >We need one operator <span 
class="pcrr8t-x-x-109">equ </span>whose components will be the equation of higher symmetries
and its consequences. Moreover, we need an operator <span 
class="pcrr8t-x-x-109">c </span>which will play the role of a
vector of constants, indexed by a counter <span 
class="pcrr8t-x-x-109">ctel</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-645">
ctel:=0;
&#x00A0;<br />operator&#x00A0;c,equ;
</div>
<!--l. 952--><p class="nopar" > We prepare a list of variables ordered by scale degree: <a 
 id="dx131-327002"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-646">
l_grad_var:=der_deg_ordering(0,all_parametric_der)$
</div>
<!--l. 957--><p class="nopar" > The function <span 
class="pcrr8t-x-x-109">der_deg_ordering </span>is defined in <span 
class="pcrr8t-x-x-109">cde.red</span>. It produces the given list
using the list <span 
class="pcrr8t-x-x-109">all_parametric_der </span>of all parametric derivatives of the given
equation up to the order <span 
class="pcrr8t-x-x-109">total_order</span>. The first two parameters can assume the values
<span 
class="cmr-10x-x-109">0 </span>or <span 
class="cmr-10x-x-109">1 </span>and say that we are considering even variables and that the variables are of
parametric type.
<!--l. 965--><p class="noindent" >Then, due to the fact that <span 
class="ptmri8t-x-x-109">all parametric variables have positive scale degree </span>then we
prepare the list <span 
class="pcrr8t-x-x-109">ansatz </span>of all graded monomials of scale degree from <span 
class="cmr-10x-x-109">0 </span>to
<span 
class="cmr-10x-x-109">5</span>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-647">
gradmon:=graded_mon(1,5,l_grad_var)$
&#x00A0;<br />gradmon:={1}&#x00A0;.&#x00A0;gradmon$
&#x00A0;<br />ansatz:=for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;gradmon&#x00A0;join&#x00A0;el$
</div>
<!--l. 972--><p class="nopar" > More precisely, the command <span 
class="pcrr8t-x-x-109">graded_mon </span>produces a list of monomials of degrees
from <span 
class="pcrr8t-x-x-109">i </span>to <span 
class="pcrr8t-x-x-109">j</span>, formed from the list of graded variables <span 
class="pcrr8t-x-x-109">l_grad_var</span>; the second
command adds the zero-degree monomial; and the last command produces a single list of
all monomials.
<!--l. 978--><p class="noindent" >Finally, we assume that the higher symmetry is a graded polynomial obtained from the
above monomials (so, it is independent of <span 
class="cmmi-10x-x-109">x </span>and <span 
class="cmmi-10x-x-109">t</span>!)
                                                                     

                                                                     
<div class="verbatim" id="verbatim-648">
sym:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;ansatz&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 982--><p class="nopar" > Next, we define the equation <span 
class="cmmi-10x-x-109">&#x2113;</span><sub><span 
class="cmmi-8">B</span></sub><span 
class="cmr-10x-x-109">(</span><span 
class="cmtt-10x-x-109">sym</span><span 
class="cmr-10x-x-109">) = 0</span>. Here, <span 
class="cmmi-10x-x-109">&#x2113;</span><sub><span 
class="cmmi-8">B</span></sub> stands for the linearization
(Section&#x00A0;<a 
href="#x131-32400016.12.8">16.12.8<!--tex4ht:ref: cdesec:linadj --></a>). A function <span 
class="pcrr8t-x-x-109">sym </span>that fulfills the above equation, on account of <span 
class="cmmi-10x-x-109">B </span><span 
class="cmr-10x-x-109">= 0</span>,
is an higher symmetry.
<!--l. 988--><p class="noindent" >We <span 
class="ptmb8t-x-x-109">cannot </span>define the linearization as a <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator in this way:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-649">
bur:={u_t&#x00A0;-&#x00A0;(2*u*u_x+u_2x)};
&#x00A0;<br />ell_function(bur,lbur);
</div>
<!--l. 992--><p class="nopar" > as the linearization is performed with respect to parametric derivatives only! This means
that the linearization has to be computed beforehand in a free jet space, then it may be
used here.
<!--l. 997--><p class="noindent" >So, the right way to go is
                                                                     

                                                                     
<div class="verbatim" id="verbatim-650">
mk_cdiffop(lbur,1,{1},1);
&#x00A0;<br />for&#x00A0;all&#x00A0;phi&#x00A0;let&#x00A0;lbur(1,1,phi)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;td(phi,t)-td(phi,x,2)-2*u*td(phi,x)-2*u_x*phi;
</div>
<!--l. 1002--><p class="nopar" > Note that for evolutionary equations the restriction of the linearization to the
equation is equivalent to just restricting total derivatives, which is automatic in
CDE.
<!--l. 1007--><p class="noindent" >The equation becomes
                                                                     

                                                                     
<div class="verbatim" id="verbatim-651">
equ&#x00A0;1:=lbur(1,1,sym);
</div>
<!--l. 1010--><p class="nopar" > At this point we initialize the equation solver. This is a part of the CDIFF package
called <span 
class="pcrr8t-x-x-109">integrator.red </span>(see the original documentation inside the folder
<span 
class="pcrr8t-x-x-109">packages/cdiff </span>in REDUCE&#8217;s source code). In our case the above package will
solve a large sparse linear system of algebraic equations on the coefficients of
<span 
class="pcrr8t-x-x-109">sym</span>.
<!--l. 1017--><p class="noindent" >The list of variables, to be passed to the equation solver:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-652">
vars:=append(indep_var,all_parametric_der);
</div>
<!--l. 1020--><p class="nopar" > The number of initial equation(s):
                                                                     

                                                                     
<div class="verbatim" id="verbatim-653">
tel:=1;
</div>
<!--l. 1024--><p class="nopar" > Next command initializes the equation solver. It passes
     <ul class="itemize1">
     <li class="itemize">the equation vector <span 
class="pcrr8t-x-x-109">equ </span>togeher with its length <span 
class="pcrr8t-x-x-109">tel </span>(<span 
class="ptmri8t-x-x-109">i.e.</span>, the total number
     of equations);
     </li>
     <li class="itemize">the  list  of  variables  with  respect  to  which  the  system  <span 
class="ptmri8t-x-x-109">must  not  </span>split  the
     equations,  <span 
class="ptmri8t-x-x-109">i.e.</span>,  variables  with  respect  to  which  the  unknowns  are  not
     polynomial. In this case this list is just <span 
class="cmsy-10x-x-109">{}</span>;
     </li>
     <li class="itemize">the constants&#8217;vector <span 
class="pcrr8t-x-x-109">c</span>, its length <span 
class="pcrr8t-x-x-109">ctel</span>, and the number of negative indexes
     if any; just <span 
class="pcrr8t-x-x-109">0</span> in our example;
     </li>
     <li class="itemize">the vector of free functions <span 
class="pcrr8t-x-x-109">f </span>that may appear in computations. Note that in
     <span 
class="cmsy-10x-x-109">{</span><span 
class="pcrr8t-x-x-109">f,0,0 </span><span 
class="cmsy-10x-x-109">} </span>the second <span 
class="pcrr8t-x-x-109">0</span> stands for the length of the vector of free functions.
     In  this  example  there  are  no  free  functions,  but  the  command  needs  the
     presence of at least a dummy argument, <span 
class="pcrr8t-x-x-109">f </span>in this case. There is also a last
     zero which is the negative length of the vector <span 
class="cmmi-10x-x-109">f</span>, just as for constants.</li></ul>
<a 
 id="dx131-327003"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-654">
initialize_equations(equ,tel,{},{c,ctel,0},{f,0,0});
</div>
<!--l. 1044--><p class="nopar" > Run the procedure <span 
class="pcrr8t-x-x-109">splitvars_opequ </span>on the first component of <span 
class="pcrr8t-x-x-109">equ </span>in order to
obtain equations on coefficiens of each monomial. <a 
 id="dx131-327004"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-655">
tel:=splitvars_opequ(equ,1,1,vars);
</div>
<!--l. 1050--><p class="nopar" > Note that <span 
class="pcrr8t-x-x-109">splitvars_opequ </span>needs to know the indices of the first and the last
equation in <span 
class="pcrr8t-x-x-109">equ</span>, and here we have only one equation as <span 
class="pcrr8t-x-x-109">equ(1)</span>. The output <span 
class="pcrr8t-x-x-109">tel </span>is
the final number of splitted equations, starting just after the initial equation
<span 
class="pcrr8t-x-x-109">equ(1)</span>.
<!--l. 1056--><p class="noindent" >Next command tells the solver the total number of equations obtained after running
<span 
class="pcrr8t-x-x-109">splitvars</span>.<a 
 id="dx131-327005"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-656">
put_equations_used&#x00A0;tel;
</div>
<!--l. 1060--><p class="nopar" > This command solves the equations for the coefficients. Note that we have to skip the
initial equations! <a 
 id="dx131-327006"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-657">
for&#x00A0;i:=2:tel&#x00A0;do&#x00A0;integrate_equation&#x00A0;i;
</div>
<!--l. 1066--><p class="nopar" >
<!--l. 1068--><p class="noindent" >The output is written in the result file by the commands
                                                                     

                                                                     
<div class="verbatim" id="verbatim-658">
off&#x00A0;echo$
&#x00A0;<br />off&#x00A0;nat$
&#x00A0;<br />out&#x00A0;&#x003C;&#x003C;resname&#x003E;&#x003E;;
&#x00A0;<br />sym:=sym;
&#x00A0;<br />write&#x00A0;~;end;~;
&#x00A0;<br />shut&#x00A0;&#x003C;&#x003C;resname&#x003E;&#x003E;;
&#x00A0;<br />on&#x00A0;nat$
&#x00A0;<br />on&#x00A0;echo$
</div>
<!--l. 1078--><p class="nopar" > The command <span 
class="pcrr8t-x-x-109">off nat </span>turns off writing in natural notation; results in this
form are better only for visualization, not for writing or for input into another
computation. The command <span 
class="pcrr8t-x-x-109">«resname» </span>forces the evaluation of the variable
<span 
class="pcrr8t-x-x-109">resname </span>to its string value. The commands <span 
class="pcrr8t-x-x-109">out </span>and <span 
class="pcrr8t-x-x-109">shut </span>are for file opening
and closing. The command <span 
class="pcrr8t-x-x-109">sym:=sym </span>is evaluated only on the right-hand
side.
<!--l. 1086--><p class="noindent" >One more example file is available; it concerns higher symmetries of the KdV equation.
In order to deal with symmetries explicitely depending on <span 
class="cmmi-10x-x-109">x </span>and <span 
class="cmmi-10x-x-109">t </span>it is possible to
use REDUCE and CDE commands in order to have <span 
class="pcrr8t-x-x-109">sym = x*</span>(something
of degree 3)  <span 
class="pcrr8t-x-x-109">+ t*</span>(something of degree 5) + (something of degree 2); this
yields scale symmetries. Or we could use <span 
class="pcrr8t-x-x-109">sym = x*</span>(something of degree 1)
<span 
class="pcrr8t-x-x-109">+ t*</span>(something of degree 3) + (something of degree 0); this yields Galilean
boosts.
<!--l. 1095--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.12    </span> <a 
 id="x131-32800016.12.12"></a>Solving the problem using CRACK</h4>
<!--l. 1097--><p class="noindent" >CRACK is a PDE solver which is devoted mostly to the solution of overdetermined PDE
systems <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>. Several mathematical problems have been solved by the help of CRACK,
like finding symmetries <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span> and conservation laws <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. The aim of CDE is to provide a
tool for computations with total derivatives, but it can be used to compute symmetries
too. In this subsection we show how to interface CDE with CRACK in order to find
higher (or generalized) symmetries for the Burgers&#8217;equation. To do that, after loading
CDE and introducing the equation, we define the linearization of the equation
<span 
class="pcrr8t-x-x-109">lbur</span>.
<!--l. 1107--><p class="noindent" >We introduce the new unknown function &#8216;<span 
class="pcrr8t-x-x-109">ansatz</span>&#8217;. We assume that the function
depends on parametric variables of order not higher than <span 
class="cmr-10x-x-109">3</span>. The variables are selected by
                                                                     

                                                                     
the function <span 
class="pcrr8t-x-x-109">selectvars </span>of CDE as follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-659">
even_vars:=for&#x00A0;i:=0:3&#x00A0;join
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;selectvars(0,i,dep_var,all_parametric_der)$
</div>
<!--l. 1113--><p class="nopar" > <a 
 id="dx131-328001"></a> In the arguments of <span 
class="pcrr8t-x-x-109">selectvars</span>, <span 
class="pcrr8t-x-x-109">0 </span>means that we want even variables, <span 
class="pcrr8t-x-x-109">i </span>stands for
the order of variables, <span 
class="pcrr8t-x-x-109">dep_var </span>stands for the dependent variables to be selected by the
command (here we use all dependent variables), <span 
class="pcrr8t-x-x-109">all_parametric_der </span>is the set of
variables where the function will extract the variables with the required properties. In the
current example we wish to get all higher symmetries depending on parametric variables
of order not higher than <span 
class="cmr-10x-x-109">3</span>.
<!--l. 1123--><p class="noindent" >The dependency of <span 
class="pcrr8t-x-x-109">ansatz </span>from the variables is given with the standard REDUCE
command <span 
class="pcrr8t-x-x-109">depend</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-660">
for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;even_vars&#x00A0;do&#x00A0;depend(ansatz,el)$
</div>
<!--l. 1127--><p class="nopar" > The equation to be solved is the equation <span 
class="pcrr8t-x-x-109">lbur(ansatz)=0</span>, hence we give the
command
                                                                     

                                                                     
<div class="verbatim" id="verbatim-661">
total_eq:=lbur(1,1,ansatz)$
</div>
<!--l. 1132--><p class="nopar" > The above command will issue an error if the list <span 
class="pcrr8t-x-x-109">{total_eq} </span>depends on the flag
variable <span 
class="pcrr8t-x-x-109">letop</span>. In this case the computation has to be redone within a jet space of
higher order.
<!--l. 1137--><p class="noindent" >The equation <span 
class="pcrr8t-x-x-109">ell_b(ansatz)=0 </span>is polynomial with respect to the variables of order
higher than those appearing in <span 
class="pcrr8t-x-x-109">ansatz</span>. For this reason, its coefficients can be put to
zero independently. This is the reason why the PDEs that determine symmetries are
overdetermined. To tell this to CRACK, we issue the command
                                                                     

                                                                     
<div class="verbatim" id="verbatim-662">
split_vars:=diffset(all_parametric_der,even_vars)$
</div>
<!--l. 1144--><p class="nopar" > The list <span 
class="pcrr8t-x-x-109">split_vars </span>contains variables which are in the current CDE jet space but <span 
class="ptmri8t-x-x-109">not</span>
in <span 
class="pcrr8t-x-x-109">even_vars</span>.
<!--l. 1148--><p class="noindent" >Then, we load the package CRACK and get results. <a 
 id="dx131-328002"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-663">
load_package&#x00A0;crack;
&#x00A0;<br />crack_results:=crack(total_eq,{},{ansatz},split_vars);
</div>
<!--l. 1153--><p class="nopar" > The results are in the variable <span 
class="pcrr8t-x-x-109">crack_results</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-664">
{{{},
&#x00A0;<br />{ansatz=(2*c_12*u_x&#x00A0;+&#x00A0;2*c_13*u*u_x&#x00A0;+&#x00A0;c_13*u_2x
&#x00A0;<br />&#x00A0;+&#x00A0;6*c_8*u**2*u_x&#x00A0;+&#x00A0;6*c_8*u*u_2x&#x00A0;+&#x00A0;2*c_8*u_3x
&#x00A0;<br />&#x00A0;+&#x00A0;6*c_8*u_x**2)/2},{c_8,c_13,c_12},
&#x00A0;<br />{}}}$
</div>
<!--l. 1161--><p class="nopar" > So, we have three symmetries; of course the generalized symmetry corresponds to <span 
class="pcrr8t-x-x-109">c_8</span>.
Remember to check <span 
class="ptmri8t-x-x-109">always </span>the output of CRACK to see if any of the symbols <span 
class="pcrr8t-x-x-109">c_n</span>
is indeed a free function depending on some of the variables, and not just a
constant.
<!--l. 1168--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.13    </span> <a 
 id="x131-32900016.12.13"></a>Local conservation laws</h4>
<!--l. 1171--><p class="noindent" >In this section we will find (some) local conservation laws for the KdV equation
<span 
class="cmmi-10x-x-109">F </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">t</span></sub> <span 
class="cmsy-10x-x-109">- </span><span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">xxx</span></sub> <span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">uu</span><sub><span 
class="cmmi-8">x</span></sub> <span 
class="cmr-10x-x-109">= 0</span>. Concretely, we have to find non-trivial <span 
class="cmr-10x-x-109">1</span>-forms
<span 
class="cmmi-10x-x-109">f </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">x</span></sub><span 
class="cmmi-10x-x-109">dx </span><span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">t</span></sub><span 
class="cmmi-10x-x-109">dt </span>on <span 
class="cmmi-10x-x-109">F </span><span 
class="cmr-10x-x-109">= 0 </span>such that <span class="bar-css"><span 
class="cmmi-10x-x-109">d</span></span><span 
class="cmmi-10x-x-109">f </span><span 
class="cmr-10x-x-109">= 0 </span>on <span 
class="cmmi-10x-x-109">F </span><span 
class="cmr-10x-x-109">= 0</span>. &#8220;Triviality&#8221; of conservation
laws is a delicate matter, for which we invite the reader to have a look in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 1177--><p class="noindent" >The files containing this example are <span 
class="pcrr8t-x-x-109">kdv_lcl1,kdv_lcl2 </span>and the corresponding
results and debug files.
<!--l. 1180--><p class="noindent" >We suppose that the conservation law has the form <span 
class="cmmi-10x-x-109">&#x03C9; </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">x</span></sub><span 
class="cmmi-10x-x-109">dx </span><span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">t</span></sub><span 
class="cmmi-10x-x-109">dt</span>. Using the same
<span 
class="pcrr8t-x-x-109">ansatz </span>as in the previous example we assume
                                                                     

                                                                     
<div class="verbatim" id="verbatim-665">
fx:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;ansatz&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
&#x00A0;<br />ft:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;ansatz&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 1185--><p class="nopar" > Next we define the equation <span class="bar-css"><span 
class="cmmi-10x-x-109">d</span></span><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">&#x03C9;</span><span 
class="cmr-10x-x-109">) = 0</span>, where <span class="bar-css"><span 
class="cmmi-10x-x-109">d</span></span> is the total exterior derivative restricted
to the equation.
                                                                     

                                                                     
<div class="verbatim" id="verbatim-666">
equ&#x00A0;1:=td(fx,t)-td(ft,x)$
</div>
<!--l. 1190--><p class="nopar" >
<!--l. 1192--><p class="noindent" >After solving the equation as in the above example we get
                                                                     

                                                                     
<div class="verbatim" id="verbatim-667">
fx&#x00A0;:=&#x00A0;c(3)*u_x&#x00A0;+&#x00A0;c(2)*u&#x00A0;+&#x00A0;c(1)$
&#x00A0;<br />ft&#x00A0;:=&#x00A0;(2*c(8)&#x00A0;+&#x00A0;2*c(3)*u*u_x&#x00A0;+&#x00A0;2*c(3)*u_3x&#x00A0;+&#x00A0;c(2)*u**2&#x00A0;+
&#x00A0;<br />2*c(2)*u_2x)/2$
</div>
<!--l. 1197--><p class="nopar" > Unfortunately it is clear that the conservation law corresponding to <span 
class="pcrr8t-x-x-109">c(3) </span>is trivial,
because it is just the KdV equation. Here this fact is evident; how to get rid of less
evident trivialities by an &#8216;automatic&#8217; mechanism? We considered this problem in the file
<span 
class="pcrr8t-x-x-109">kdv_lcl2</span>, where we solved the equation
                                                                     

                                                                     
<div class="verbatim" id="verbatim-668">
equ&#x00A0;1:=fx-td(f0,x);
&#x00A0;<br />equ&#x00A0;2:=ft-td(f0,t);
</div>
<!--l. 1206--><p class="nopar" > after having loaded the values <span 
class="pcrr8t-x-x-109">fx </span>and <span 
class="pcrr8t-x-x-109">ft </span>found by the previous program. In order to do
that we have to introduce two new counters:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-669">
operator&#x00A0;cc,equ;
&#x00A0;<br />cctel:=0;
</div>
<!--l. 1212--><p class="nopar" > We make the following ansatz on <span 
class="pcrr8t-x-x-109">f0</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-670">
f0:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;ansatz&#x00A0;sum&#x00A0;(cc(cctel:=cctel+1)*el))$
</div>
<!--l. 1216--><p class="nopar" > After solving the system, issuing the commands
                                                                     

                                                                     
<div class="verbatim" id="verbatim-671">
fxnontriv&#x00A0;:=&#x00A0;fx-td(f0,x);
&#x00A0;<br />ftnontriv&#x00A0;:=&#x00A0;ft-td(f0,t);
</div>
<!--l. 1221--><p class="nopar" > we obtain
                                                                     

                                                                     
<div class="verbatim" id="verbatim-672">
fxnontriv&#x00A0;:=&#x00A0;c(2)*u$
&#x00A0;<br />ftnontriv&#x00A0;:=&#x00A0;(c(2)*(u**2&#x00A0;+&#x00A0;2*u_2x))/2$
</div>
<!--l. 1226--><p class="nopar" > This mechanism can be easily generalized to situations in which the conservation laws
which are found by the program are difficult to treat by pen and paper. However,
we will present another approach to the computation of conservation laws in
subsection&#x00A0;<a 
href="#x131-34100016.12.25">16.12.25<!--tex4ht:ref: cdesec:plebanski-equation --></a>.
<!--l. 1232--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.14    </span> <a 
 id="x131-33000016.12.14"></a>Local Hamiltonian operators</h4>
<!--l. 1235--><p class="noindent" >In this section we will show how to compute local Hamiltonian operators for
Korteweg&#8211;de Vries, Boussinesq and Kadomtsev&#8211;Petviashvili equations. It is interesting
to note that we will adopt the same computational scheme for all equations, even
if the latter is not in evolutionary form and it has more than two independent
variables. This comes from a new mathematical theory which started in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span> for
evolution equations and was later extended to general differential equations in
<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 1243--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.15    </span> <a 
 id="x131-33100016.12.15"></a>Korteweg&#8211;de Vries equation</h4>
<!--l. 1246--><p class="noindent" >Here we will find local Hamiltonian operators for the KdV equation <span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">t</span></sub> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">u</span><sub><span 
class="cmmi-8">xxx</span></sub> <span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">uu</span><sub><span 
class="cmmi-8">x</span></sub>. A
necessary condition for an operator to be Hamiltonian is that it sends generating
functions (or characteristics, according with <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>) of conservation laws to higher (or
generalized) symmetries. As it is proved in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>, this amounts at solving <span class="bar-css"><span 
class="cmmi-10x-x-109">&#x2113;</span></span><sub><span 
class="cmmi-8">KdV</span> </sub><span 
class="cmr-10x-x-109">(</span><span 
class="cmtt-10x-x-109">phi</span><span 
class="cmr-10x-x-109">) = 0</span>
over the equation
<center class="math-display" >
<img 
src="manual129x.png" alt="{
  ut = uxxx + uux
  pt = pxxx + upx
" class="math-display" ></center>
<!--l. 1257--><p class="nopar" >
or, in geometric terminology, find the shadows of symmetries on the <span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup>-covering of the
                                                                     

                                                                     
KdV equation, with the further condition that the shadows must be linear in the
<span 
class="cmmi-10x-x-109">p</span>-variables. Note that the second equation (in odd variables!) is just the adjoint of the
linearization of the KdV equation applied to an odd variable.
<!--l. 1264--><p class="noindent" >The file containing this example is <span 
class="pcrr8t-x-x-109">kdv_lho1</span>.
<!--l. 1266--><p class="noindent" >We stress that the linearization <span class="bar-css"><span 
class="cmmi-10x-x-109">&#x2113;</span></span><sub><span 
class="cmmi-8">KdV</span> </sub><span 
class="cmr-10x-x-109">(</span><span 
class="cmtt-10x-x-109">phi</span><span 
class="cmr-10x-x-109">) = 0 </span>is the equation
                                                                     

                                                                     
<div class="verbatim" id="verbatim-673">
td(phi,t)-u*td(phi,x)-u_x*phi-td(phi,x,3)=0
</div>
<!--l. 1270--><p class="nopar" > but the total derivatives are lifted to the <span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup> covering, hence they contain also
derivatives with respect to <span 
class="cmmi-10x-x-109">p</span>&#8217;s. We can define a linearization operator <span 
class="pcrr8t-x-x-109">lkdv </span>as
usual.
<!--l. 1275--><p class="noindent" >In order to produce an ansatz which is a superfunction of one odd variable (or a linear
function in odd variables) we produce two lists: the list <span 
class="pcrr8t-x-x-109">l_grad_var </span>of all even
variables collected by their gradings and a similar list <span 
class="pcrr8t-x-x-109">l_grad_odd </span>for odd
variables:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-674">
l_grad_var:=der_deg_ordering(0,all_parametric_der)$
&#x00A0;<br />l_grad_odd:={1}&#x00A0;.&#x00A0;der_deg_ordering(1,all_parametric_odd)$
&#x00A0;<br />gradmon:=graded_mon(1,10,l_grad_var)$
&#x00A0;<br />gradmon:={1}&#x00A0;.&#x00A0;gradmon$
</div>
<!--l. 1284--><p class="nopar" > We need a list of graded monomials which are linear in odd variables. The function
<span 
class="pcrr8t-x-x-109">mkalllinodd </span>produces all monomials which are linear with respect to the variables
from <span 
class="pcrr8t-x-x-109">l_grad_odd</span>, have (monomial) coefficients from the variables in <span 
class="pcrr8t-x-x-109">l_grad_var</span>,
and have total scale degrees from <span 
class="cmr-10x-x-109">1 </span>to <span 
class="cmr-10x-x-109">6</span>. Such monomials are then converted to the
internal representation of odd variables. <a 
 id="dx131-331001"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-675">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,6)$
</div>
<!--l. 1294--><p class="nopar" > Note that all odd variables have positive scale degrees thanks to our initial choice
<span 
class="pcrr8t-x-x-109">deg_odd_var:=1;</span>. Finally, the ansatz for local Hamiltonian operators:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-676">
sym:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linext&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 1300--><p class="nopar" > After having set
                                                                     

                                                                     
<div class="verbatim" id="verbatim-677">
equ&#x00A0;1:=lkdv(1,1,sym);
</div>
<!--l. 1304--><p class="nopar" > and having initialized the equation solver as before, we do <span 
class="pcrr8t-x-x-109">splitext</span><a 
 id="dx131-331002"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-678">
tel:=splitext_opequ(equ,1,1);
</div>
<!--l. 1309--><p class="nopar" > in order to split the polynomial equation with respect to the <span 
class="pcrr8t-x-x-109">ext </span>variables, then
<span 
class="pcrr8t-x-x-109">splitvars</span>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-679">
tel2:=splitvars_opequ(equ,2,tel,vars);
</div>
<!--l. 1314--><p class="nopar" > in order to split the resulting polynomial equation in a list of equations on the
coefficients of all monomials.
<!--l. 1318--><p class="noindent" >Now we are ready to solve all equations:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-680">
put_equations_used&#x00A0;tel;
&#x00A0;<br />for&#x00A0;i:=2:tel&#x00A0;do&#x00A0;integrate_equation&#x00A0;i;
&#x00A0;<br />end;
</div>
<!--l. 1323--><p class="nopar" > Note that we want <span 
class="ptmri8t-x-x-109">all </span>equations to be solved!
<!--l. 1326--><p class="noindent" >The results are the two well-known Hamiltonian operators for the KdV. After integration
the function <span 
class="pcrr8t-x-x-109">sym </span>becomes
                                                                     

                                                                     
<div class="verbatim" id="verbatim-681">
sym&#x00A0;:=&#x00A0;(c(5)*p*u_x&#x00A0;+&#x00A0;2*c(5)*p_x*u&#x00A0;+
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;3*c(5)*p_3x&#x00A0;+&#x00A0;3*c(2)*p_x)/3$
</div>
<!--l. 1331--><p class="nopar" > Of course, the results correspond to the operators <div 
class="gather-star"><img 
src="manual130x.png" alt="                  px &#x2192; Dx,
1-(3p   + 2up  + u p) &#x2192; 1-(3D    + 2uD   + u )
3    3x      x    x     3    xxx      x    x
" ></div>Note that each operator is multiplied by one arbitrary real constant, <span 
class="pcrr8t-x-x-109">c(5) </span>and
<span 
class="pcrr8t-x-x-109">c(2)</span>.
<!--l. 1340--><p class="noindent" >The same problem can be approached using CRACK, as follows (file <span 
class="pcrr8t-x-x-109">kdv_lho2.red</span>).
An ansatz is constructed by the following instructions:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-682">
even_vars:=for&#x00A0;i:=0:3&#x00A0;join
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;selectvars(0,i,dep_var,all_parametric_der)$
&#x00A0;<br />odd_vars:=for&#x00A0;i:=0:3&#x00A0;join
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;selectvars(1,i,odd_var,all_parametric_odd)$
&#x00A0;<br />ext_vars:=replace_oddext(odd_vars)$
&#x00A0;<br />
&#x00A0;<br />ctemp:=0$
&#x00A0;<br />ansatz:=for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;ext_vars&#x00A0;sum
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;mkid(s,ctemp:=ctemp+1)*el$
</div>
<!--l. 1353--><p class="nopar" > Note that we have
                                                                     

                                                                     
<div class="verbatim" id="verbatim-683">
ansatz&#x00A0;:=&#x00A0;p*s1&#x00A0;+&#x00A0;p_2x*s3&#x00A0;+&#x00A0;p_3x*s4&#x00A0;+&#x00A0;p_x*s2$
</div>
<!--l. 1357--><p class="nopar" > Indeed, we are looking for a third-order operator whose coefficients depend on
variables of order not higher than <span 
class="cmr-10x-x-109">3</span>. This last property has to be introduced
by
                                                                     

                                                                     
<div class="verbatim" id="verbatim-684">
unk:=for&#x00A0;i:=1:ctemp&#x00A0;collect&#x00A0;mkid(s,i)$
&#x00A0;<br />for&#x00A0;each&#x00A0;ell&#x00A0;in&#x00A0;unk&#x00A0;do
&#x00A0;<br />&#x00A0;for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;even_vars&#x00A0;do&#x00A0;depend&#x00A0;ell,el$
</div>
<!--l. 1365--><p class="nopar" > Then, we introduce the linearization (lifted on the cotangent covering)
                                                                     

                                                                     
<div class="verbatim" id="verbatim-685">
operator&#x00A0;ell_f$
&#x00A0;<br />for&#x00A0;all&#x00A0;sym&#x00A0;let&#x00A0;ell_f(sym)=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;td(sym,t)&#x00A0;-&#x00A0;u*td(sym,x)&#x00A0;-&#x00A0;u_x*sym&#x00A0;-&#x00A0;td(sym,x,3)$
</div>
<!--l. 1371--><p class="nopar" > and the equation to be solved, together with the usual test that checks for the nedd to
enlarge the jet space:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-686">
total_eq:=ell_f(ansatz)$
</div>
<!--l. 1376--><p class="nopar" > Finally, we split the above equation by collecting all coefficients of odd variables:<a 
 id="dx131-331003"></a>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-687">
system_eq:=splitext_list({total_eq})$
</div>
<!--l. 1381--><p class="nopar" > and we feed CRACK with the equations that consist in asking to the above coefficients
to be zero:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-688">
load_package&#x00A0;crack;
&#x00A0;<br />crack_results:=crack(system_eq,{},unk,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;diffset(all_parametric_der,even_vars));
</div>
<!--l. 1388--><p class="nopar" > The results are the same as in the previous section:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-689">
crack_results&#x00A0;:=&#x00A0;{{{},
&#x00A0;<br />{s4=(3*c_17)/2,s3=0,s2=c_16&#x00A0;+&#x00A0;c_17*u,s1=(c_17*u_x)/2},
&#x00A0;<br />{c_17,c_16},
&#x00A0;<br />{}}}$
</div>
<!--l. 1395--><p class="nopar" >
<!--l. 1398--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.16    </span> <a 
 id="x131-33200016.12.16"></a>Boussinesq equation</h4>
<!--l. 1401--><p class="noindent" >There is no conceptual difference when computing for systems of PDEs with respect to
the previous computations for scalar equations. We will look for Hamiltonian structures
for the dispersionless Boussinesq equation (<a 
href="#x131-324001r58">16.58<!--tex4ht:ref: cdeeq:1 --></a>).
<!--l. 1405--><p class="noindent" >We will proceed by dimensional analysis. Gradings can be taken as
<center class="math-display" >
<img 
src="manual131x.png" alt="[t] = - 2, [x] = - 1, [v] = 1, [u] = 2, [p] = 1, [q] = 2
" class="math-display" ></center>
<!--l. 1408--><p class="nopar" >
where <span 
class="cmmi-10x-x-109">p</span>, <span 
class="cmmi-10x-x-109">q </span>are the two odd coordinates. We have the <span 
class="cmmi-10x-x-109">&#x2113;</span><sub>Bou</sub><sup><span 
class="cmsy-8">*</span></sup> covering equation
<center class="math-display" >
<img 
src="manual132x.png" alt="(
|  - pt + vpx + qx = 0
|{  upx + &#x03C3;pxxx - qt + vqx = 0
|  u - u v - uv  - &#x03C3;v   = 0
|(   t   x      x     xxx
   vt - ux - vvx = 0
" class="math-display" ><a 
 id="x131-33200016.12.16"></a></center>
<!--l. 1421--><p class="nopar" >
We have to find Hamiltonian operators as shadows of symmetries on the above covering.
At the level of source file (<span 
class="pcrr8t-x-x-109">bou_lho1</span>) the input data is:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-690">
indep_var:={x,t}$
&#x00A0;<br />dep_var:={u,v}$
&#x00A0;<br />odd_var:={p,q}$
&#x00A0;<br />deg_indep_var:={-1,-2}$
&#x00A0;<br />deg_dep_var:={2,1}$
&#x00A0;<br />deg_odd_var:={1,2}$
&#x00A0;<br />total_order:=8$
&#x00A0;<br />principal_der:={u_t,v_t}$
&#x00A0;<br />de:={u_x*v+u*v_x+sig*v_3x,u_x+v*v_x}$
&#x00A0;<br />principal_odd:={p_t,q_t}$
&#x00A0;<br />de_odd:={v*p_x+q_x,u*p_x+sig*p_3x+v*q_x}$
</div>
<!--l. 1437--><p class="nopar" > The ansatz for the components of the Hamiltonian operator, of scale degree between <span 
class="cmr-10x-x-109">1</span>
and <span 
class="cmr-10x-x-109">6</span>, is
                                                                     

                                                                     
<div class="verbatim" id="verbatim-691">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,6)$
&#x00A0;<br />phi1:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linodd&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
&#x00A0;<br />phi2:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linodd&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 1444--><p class="nopar" > and the equation for shadows of symmetries is (<span 
class="pcrr8t-x-x-109">lbou2 </span>is taken from Section&#x00A0;<a 
href="#x131-32400016.12.8">16.12.8<!--tex4ht:ref: cdesec:linadj --></a>)
                                                                     

                                                                     
<div class="verbatim" id="verbatim-692">
equ&#x00A0;1:=lbou2(1,1,phi1)&#x00A0;+&#x00A0;lbou2(1,2,phi2);
&#x00A0;<br />
&#x00A0;<br />equ&#x00A0;2:=lbou2(2,1,phi1)&#x00A0;+&#x00A0;lbou2(2,2,phi2);
</div>
<!--l. 1451--><p class="nopar" > After the usual procedures for decomposing polynomials we obtain three local
Hamiltonian operators:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-693">
phi1_odd&#x00A0;:=&#x00A0;(2*c(31)*p*sig*v_3x&#x00A0;+&#x00A0;2*c(31)*p*u*v_x
&#x00A0;<br />&#x00A0;+&#x00A0;2*c(31)*p*u_x*v&#x00A0;+&#x00A0;6*c(31)*p_2x*sig*v_x
&#x00A0;<br />&#x00A0;+&#x00A0;4*c(31)*p_3x*sig*v&#x00A0;+&#x00A0;6*c(31)*p_x*sig*v_2x
&#x00A0;<br />&#x00A0;+&#x00A0;4*c(31)*p_x*u*v&#x00A0;+&#x00A0;2*c(31)*q*u_x&#x00A0;+&#x00A0;4*c(31)*q_3x*sig
&#x00A0;<br />&#x00A0;+&#x00A0;4*c(31)*q_x*u&#x00A0;+&#x00A0;c(31)*q_x*v**2&#x00A0;+&#x00A0;2*c(16)*p*u_x
&#x00A0;<br />&#x00A0;+&#x00A0;4*c(16)*p_3x*sig&#x00A0;+&#x00A0;4*c(16)*p_x*u
&#x00A0;<br />&#x00A0;+&#x00A0;2*c(16)*q_x*v&#x00A0;+&#x00A0;2*c(10)*q_x)/2$
&#x00A0;<br />
&#x00A0;<br />phi2_odd&#x00A0;:=&#x00A0;(2*c(31)*p*u_x&#x00A0;+&#x00A0;2*c(31)*p*v*v_x
&#x00A0;<br />&#x00A0;+&#x00A0;4*c(31)*p_3x*sig&#x00A0;+&#x00A0;4*c(31)*p_x*u
&#x00A0;<br />&#x00A0;+&#x00A0;c(31)*p_x*v**2&#x00A0;+&#x00A0;2*c(31)*q*v_x&#x00A0;+&#x00A0;4*c(31)*q_x*v
&#x00A0;<br />&#x00A0;+&#x00A0;2*c(16)*p*v_x&#x00A0;+&#x00A0;2*c(16)*p_x*v
&#x00A0;<br />&#x00A0;+&#x00A0;4*c(16)*q_x&#x00A0;+&#x00A0;2*c(10)*p_x)/2$
</div>
<!--l. 1469--><p class="nopar" >
There is a whole hierarchy of nonlocal Hamiltonian operators&#x00A0;<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 1474--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.17    </span> <a 
 id="x131-33300016.12.17"></a>Kadomtsev&#8211;Petviashvili equation</h4>
<!--l. 1477--><p class="noindent" >There is no conceptual difference in symbolic computations of Hamiltonian operators for
PDEs in <span 
class="cmr-10x-x-109">2 </span>independent variables and in more than <span 
class="cmr-10x-x-109">2 </span>independent variables, regardless of
the fact that the equation at hand is written in evolutionary form. As a model example,
we consider the KP equation
<table 
class="equation"><tr><td><a 
 id="x131-333001r59"></a>
<center class="math-display" >
<img 
src="manual133x.png" alt="            2          1--
uyy = utx - ux - uuxx - 12uxxxx.
" class="math-display" ></center></td><td class="equation-label">(16.59)</td></tr></table>
<!--l. 1484--><p class="nopar" >
Proceeding as in the above examples we input the following data:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-694">
indep_var:={t,x,y}$
&#x00A0;<br />dep_var:={u}$
&#x00A0;<br />odd_var:={p}$
&#x00A0;<br />deg_indep_var:={-3,-2,-1}$
&#x00A0;<br />deg_dep_var:={2}$
&#x00A0;<br />deg_odd_var:={1}$
&#x00A0;<br />total_order:=6$
&#x00A0;<br />principal_der:={u_2y}$
&#x00A0;<br />de:={u_tx-u_x**2-u*u_2x-(1/12)*u_4x}$
&#x00A0;<br />principal_odd:={p_2y}$
&#x00A0;<br />de_odd:={p_tx-u*p_2x-(1/12)*p_4x}$
</div>
<!--l. 1498--><p class="nopar" > and look for Hamiltonian operators of scale degree between <span 
class="cmr-10x-x-109">1 </span>and <span 
class="cmr-10x-x-109">5</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-695">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,5)$
&#x00A0;<br />phi:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linodd&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 1503--><p class="nopar" > After solving the equation for shadows of symmetries in the cotangent covering
                                                                     

                                                                     
<div class="verbatim" id="verbatim-696">
equ&#x00A0;1:=td(phi,y,2)&#x00A0;-&#x00A0;td(phi,x,t)&#x00A0;+&#x00A0;2*u_x*td(phi,x)
&#x00A0;<br />&#x00A0;+&#x00A0;u_2x*phi&#x00A0;+&#x00A0;u*td(phi,x,2)&#x00A0;+&#x00A0;(1/12)*td(phi,x,4);
</div>
<!--l. 1508--><p class="nopar" > we get the only local Hamiltonian operator
                                                                     

                                                                     
<div class="verbatim" id="verbatim-697">
phi&#x00A0;:=&#x00A0;c(13)*p_2x$
</div>
<!--l. 1512--><p class="nopar" > As far as we know there are no further local Hamiltonian operators.
<!--l. 1515--><p class="noindent" ><span 
class="ptmb8t-x-x-109">Remark</span>: the above Hamiltonian operator is already known in an evolutionary
presentation of the KP equation <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. Our mathematical theory of Hamiltonian operators
for general differential equations <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span> allows us to formulate and solve the problem for
any presentation of the KP equation. Change of coordinate formulae could also be
provided.
<!--l. 1524--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.18    </span> <a 
 id="x131-33400016.12.18"></a>Examples of Schouten bracket of local Hamiltonian operators</h4>
<!--l. 1527--><p class="noindent" >Let <span 
class="cmmi-10x-x-109">F </span><span 
class="cmr-10x-x-109">= 0 </span>be a system of PDEs. Here <span 
class="cmmi-10x-x-109">F </span><span 
class="cmsy-10x-x-109">&#x2208; </span><span 
class="cmmi-10x-x-109">P </span>, where <span 
class="cmmi-10x-x-109">P </span>is the module (in the algebraic
sense) of vector functions <span 
class="cmmi-10x-x-109">P </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmsy-10x-x-109">{</span><span 
class="cmmi-10x-x-109">J</span><sup><span 
class="cmmi-8">r</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">n,m</span><span 
class="cmr-10x-x-109">) </span><span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">k</span></sup><span 
class="cmsy-10x-x-109">}</span>.
<!--l. 1530--><p class="noindent" >The Hamiltonian operators which have been computed in the previous Section are
differential operators sending generating functions of conservation laws into generating
functions of symmetries for the above system of PDEs:
<table 
class="equation"><tr><td><a 
 id="x131-334001r60"></a>
<center class="math-display" >
<img 
src="manual134x.png" alt="H : &#x02C6;P &#x2192; &#x03F0;
" class="math-display" ></center></td><td class="equation-label">(16.60)</td></tr></table>
<!--l. 1536--><p class="nopar" >
     <ul class="itemize1">
     <li class="itemize"><img 
src="manual135x.png" alt=" &#x02C6;
P"  class="circ" > <span 
class="cmr-10x-x-109">=  </span><span 
class="cmsy-10x-x-109">{</span><span 
class="cmmi-10x-x-109">J</span><sup><span 
class="cmmi-8">r</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">n,m</span><span 
class="cmr-10x-x-109">)  </span><span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="cmr-10x-x-109">(</span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">k</span></sup><span 
class="cmr-10x-x-109">)</span><sup><span 
class="cmsy-8">*</span></sup> <span 
class="cmsy-10x-x-109">&#x2297;&#x2227;</span><sup><span 
class="cmmi-8">n</span></sup><span 
class="cmmi-10x-x-109">T</span><sup><span 
class="cmsy-8">*</span></sup><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">n</span></sup><span 
class="cmsy-10x-x-109">} </span>is  the  space  of  covector-valued
     densities,
                                                                     

                                                                     
     </li>
     <li class="itemize"><span 
class="msbm-10x-x-109">&#x03F0;  </span><span 
class="cmr-10x-x-109">=  </span><span 
class="cmsy-10x-x-109">{</span><span 
class="cmmi-10x-x-109">J</span><sup><span 
class="cmmi-8">r</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">n,m</span><span 
class="cmr-10x-x-109">)  </span><span 
class="cmsy-10x-x-109">&#x2192; </span><span 
class="msbm-10x-x-109">&#x211D;</span><sup><span 
class="cmmi-8">m</span></sup><span 
class="cmsy-10x-x-109">} </span>is  the  space  of  generalized  vector  fields  on
     jets; generating functions of higher symmetries of the system of PDEs are
     elements of this space.</li></ul>
<!--l. 1544--><p class="noindent" >As the operators are mainly used to define a bracket operation and a Lie algebra structure
on conservation laws, two properties are required: skew-adjointness <span 
class="cmmi-10x-x-109">H</span><sup><span 
class="cmsy-8">*</span></sup> <span 
class="cmr-10x-x-109">= </span><span 
class="cmsy-10x-x-109">-</span><span 
class="cmmi-10x-x-109">H</span>
(corresponding with skew-symmetry of the bracket) and <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">H,H</span><span 
class="cmr-10x-x-109">] = 0 </span>(corresponding with
the Jacobi property of the bracket).
<!--l. 1549--><p class="noindent" >In order to compute the two properties we proceed as follows. Skew-adjointness is
checked by computing the adjoint and verifying that the sum with the initial operator is
zero.
<!--l. 1553--><p class="noindent" >In the case of evolutionary equations, <span 
class="cmmi-10x-x-109">P </span><span 
class="cmr-10x-x-109">= </span><span 
class="msbm-10x-x-109">&#x03F0;</span>, and Hamiltonian operators&#x00A0;(<a 
href="#x131-334001r60">16.60<!--tex4ht:ref: eq:15 --></a>) can
also be interpreted as <span 
class="ptmri8t-x-x-109">variational bivectors, ie</span>
<table 
class="equation"><tr><td><a 
 id="x131-334002r61"></a>
<center class="math-display" >
<img 
src="manual136x.png" alt="H&#x02C6;: &#x02C6;&#x03F0; &#x00D7; &#x02C6;&#x03F0; &#x2192; &#x2227;nT *&#x211D;n
" class="math-display" ></center></td><td class="equation-label">(16.61)</td></tr></table>
<!--l. 1559--><p class="nopar" >
where the correspondence is given by
<table 
class="equation"><tr><td><a 
 id="x131-334003r62"></a>
<center class="math-display" >
<img 
src="manual137x.png" alt="H (&#x03C8;) = (aij&#x03C3;D  &#x03C8; )   &#x2192;   H&#x02C6;(&#x03C8; ,&#x03C8;  ) = (aij&#x03C3;D &#x03C8;   &#x03C8;  )
              &#x03C3; j            1   2         &#x03C3;  1 j 2 i
" class="math-display" ></center></td><td class="equation-label">(16.62)</td></tr></table>
                                                                     

                                                                     
<!--l. 1566--><p class="nopar" >
<!--l. 1568--><p class="noindent" >In terms of the corresponding superfunctions:
<center class="math-display" >
<img 
src="manual138x.png" alt="H =  aik&#x03C3;pk&#x03C3;   &#x2192;    &#x02C6;H = aik&#x03C3;pk&#x03C3;pi.
" class="math-display" ></center>
<!--l. 1572--><p class="nopar" >
Note that the product <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">k</span><span style="margin-left:0.3em" class="thinspace"></span><span 
class="cmmi-8">&#x03C3;</span></sub><span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">i</span></sub> is anticommutative since <span 
class="cmmi-10x-x-109">p</span>&#8217;s are odd variables.
<!--l. 1576--><p class="noindent" >After that a <span 
class="cmsy-10x-x-109"><img 
src="cmsy10-43.png" alt="C" class="10-109x-x-43" /></span>-differential operator of the type of <span 
class="cmmi-10x-x-109">H </span>has been converted into a bivector it
is possible to apply the formulae (<a 
href="#x131-323002r56">16.56<!--tex4ht:ref: eq:11 --></a>) and&#x00A0;(<a 
href="#x131-323003r57">16.57<!--tex4ht:ref: eq:14 --></a>) in order to compute the Schouten
bracket. This is what we will see in next section.
<!--l. 1581--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.19    </span> <a 
 id="x131-33500016.12.19"></a>Bi-Hamiltonian structure of the KdV equation</h4>
<!--l. 1584--><p class="noindent" >We can do the above computations using KdV equation as a test case (see the file
<span 
class="pcrr8t-x-x-109">kdv_lho3.red</span>).
<!--l. 1587--><p class="noindent" >Let us load the above operators:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-698">
operator&#x00A0;ham1;
&#x00A0;<br />for&#x00A0;all&#x00A0;psi1&#x00A0;let&#x00A0;ham1(psi1)=td(psi1,x);
&#x00A0;<br />operator&#x00A0;ham2;
&#x00A0;<br />for&#x00A0;all&#x00A0;psi2&#x00A0;let&#x00A0;ham2(psi2)=
&#x00A0;<br />&#x00A0;(1/3)*u_x*psi2&#x00A0;+&#x00A0;td(psi2,x,3)&#x00A0;+&#x00A0;(2/3)*u*td(psi2,x);
</div>
<!--l. 1594--><p class="nopar" > We may convert the two operators into the corresponding superfunctions
                                                                     

                                                                     
<div class="verbatim" id="verbatim-699">
conv_cdiff2superfun(ham1,sym1);
&#x00A0;<br />conv_cdiff2superfun(ham2,sym2);
</div>
<!--l. 1599--><p class="nopar" > The result of the conversion is
                                                                     

                                                                     
<div class="verbatim" id="verbatim-700">
sym1(1)&#x00A0;:=&#x00A0;{p_x};
&#x00A0;<br />sym2(2)&#x00A0;:=&#x00A0;{(1/3)*p*u_x&#x00A0;+&#x00A0;p_3x&#x00A0;+&#x00A0;(2/3)*p_x*u};
</div>
<!--l. 1604--><p class="nopar" > Skew-adjointness is checked at once:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-701">
adjoint_cdiffop(ham1,ham1_star);
&#x00A0;<br />adjoint_cdiffop(ham2,ham2_star);
&#x00A0;<br />ham1_star_sf(1)+sym1(1);
&#x00A0;<br />ham2_star_sf(1)+sym2(1);
</div>
<!--l. 1611--><p class="nopar" > and the result of the last two commands is zero.
<!--l. 1614--><p class="noindent" >Then we shall convert the two superfunctions into bivectors:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-702">
conv_genfun2biv(sym1_odd,biv1);
&#x00A0;<br />conv_genfun2biv(sym2_odd,biv2);
</div>
<!--l. 1618--><p class="nopar" > The output is:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-703">
biv1(1)&#x00A0;:=&#x00A0;&#x00A0;-&#x00A0;ext(p,p_x);
&#x00A0;<br />biv2(1)&#x00A0;:=&#x00A0;-&#x00A0;(1/3)*(&#x00A0;-&#x00A0;3*ext(p,p_3x)&#x00A0;-&#x00A0;2*ext(p,p_x)*u);
</div>
<!--l. 1623--><p class="nopar" > Finally, the three Schouten brackets <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">&#x0124;</span><sub><span 
class="cmmi-8">i</span></sub><span 
class="cmmi-10x-x-109">,</span><span 
class="cmmi-10x-x-109">&#x0124;</span><sub><span 
class="cmmi-8">j</span></sub><span 
class="cmr-10x-x-109">] </span>are computed, with <span 
class="cmmi-10x-x-109">i,j </span><span 
class="cmr-10x-x-109">= 1</span><span 
class="cmmi-10x-x-109">,</span><span 
class="cmr-10x-x-109">2</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-704">
schouten_bracket(biv1,biv1,sb11);
&#x00A0;<br />schouten_bracket(biv1,biv2,sb12);
&#x00A0;<br />schouten_bracket(biv2,biv2,sb22);
</div>
<!--l. 1630--><p class="nopar" > the result are well-known lists of zeros.
<!--l. 1633--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.20    </span> <a 
 id="x131-33600016.12.20"></a>Bi-Hamiltonian structure of the WDVV equation</h4>
<!--l. 1636--><p class="noindent" >This subsection refers to the the example file <span 
class="pcrr8t-x-x-109">wdvv_biham1.red</span>. The simplest
nontrivial case of the WDVV equations is the third-order Monge&#8211;Ampère equation,
<span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">ttt</span></sub> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">xxt</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmsy-10x-x-109">- </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">xxx</span></sub><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">xtt</span></sub> <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. This PDE can be transformed into hydrodynamic
form,
<table 
class="equation-star"><tr><td>
<center class="math-display" >
<img 
src="manual139x.png" alt="at = bx, bt = cx,  ct = (b2 - ac)x,
" class="math-display" ></center></td></tr></table>
<!--l. 1643--><p class="nopar" >
via the change of variables <span 
class="cmmi-10x-x-109">a </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">xxx</span></sub>, <span 
class="cmmi-10x-x-109">b </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">xxt</span></sub>, <span 
class="cmmi-10x-x-109">c </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">f</span><sub><span 
class="cmmi-8">xtt</span></sub>. This system possesses two
Hamiltonian formulations <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>:
<table 
class="equation-star"><tr><td>
<center class="math-display" >
                                                                     

                                                                     
<img 
src="manual140x.png" alt="(a )      ( &#x03B4;H  &#x2215;&#x03B4;a)
(  )      (    i   )
  b   = Ai  &#x03B4;Hi &#x2215;&#x03B4;b  ,  i = 1,2
  c t       &#x03B4;Hi &#x2215;&#x03B4;c
" class="math-display" ></center></td></tr></table>
<!--l. 1653--><p class="nopar" >
with the homogeneous first-order Hamiltonian operator
<center class="math-display" >
<img 
src="manual141x.png" alt="     ( - 3 Dx     1Dxa                 Dxb           )
&#x02C6;A  = ( 12aD    1(D 2b+ bD  )         3cD  +  c        )
 1     2bD x  2 3Dx c- c x   (b2 - ac2)D  x+ D x(b2 - ac)
          x     2  x    x             x     x
" class="math-display" ></center>
<!--l. 1665--><p class="nopar" >
with the Hamiltonian <span 
class="cmmi-10x-x-109">H</span><sub><span 
class="cmr-8">1</span></sub> <span 
class="cmr-10x-x-109">=</span> <span 
class="cmex-10x-x-109">&#x222B;</span>
  <span 
class="cmmi-10x-x-109">c</span><span style="margin-left:0.3em" class="thinspace"></span><span 
class="cmmi-10x-x-109">dx</span>, and the homogeneous third-order Hamiltonian
operator
<center class="math-display" >
<img 
src="manual142x.png" alt="        (   0     0           D          )
A  = D  (   0    D           - D xa      ) D  ,
 2     x          x             x            x
           Dx  - aDx   Dxb + bDx + aDxa " class="math-display" ></center> with
the nonlocal Hamiltonian
<center class="math-display" >
<img 
src="manual143x.png" alt="        &#x222B; (                          )
H  =  -     1a(D  -1b)2 + D - 1bD  -1c  dx.
  2         2    x         x     x
" class="math-display" ></center>
<!--l. 1682--><p class="nopar" >
Both operators are of Dubrovin&#8211;Novikov type <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>,&#x00A0;<span 
class="ptmb8t-x-x-109">?</span>]</span>. This means that the operators are
homogeneous with respect to the grading <span 
class="cmsy-10x-x-109">|</span><span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmmi-8">x</span></sub><span 
class="cmsy-10x-x-109">| </span><span 
class="cmr-10x-x-109">= 1</span>. It follows that the operators are
form-invariant under point transformations of the dependent variables, <span 
class="cmmi-10x-x-109">u</span><sup><span 
class="cmmi-8">i</span></sup> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">u</span><sup><span 
class="cmmi-8">i</span></sup><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">&#x0169;</span><sup><span 
class="cmmi-8">j</span></sup><span 
class="cmr-10x-x-109">)</span>. Here
and in what follows we will use the letters <span 
class="cmmi-10x-x-109">u</span><sup><span 
class="cmmi-8">i</span></sup> to denote the dependent variables
                                                                     

                                                                     
<span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">a,b,c</span><span 
class="cmr-10x-x-109">)</span>. Under such transformations, the coefficients of the operators transform as
differential-geometric objects.
<!--l. 1691--><p class="noindent" >The operator <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">1</span></sub> has the general structure
<center class="math-display" >
<img 
src="manual144x.png" alt="A1 = gi1jDx + &#x0393; ijukx
              k
" class="math-display" ></center>
<!--l. 1694--><p class="nopar" >
where the covariant metric <span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmr-8">1</span><span style="margin-left:0.3em" class="thinspace"></span><span 
class="cmmi-8">ij</span></sub> is flat, <span 
class="cmr-10x-x-109">&#x0393;</span><sub><span 
class="cmmi-8">k</span></sub><sup><span 
class="cmmi-8">ij</span></sup> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmr-8">1</span></sub><sup><span 
class="cmmi-8">is</span></sup><span 
class="cmr-10x-x-109">&#x0393;</span><sub><span 
class="cmmi-8">sk</span></sub><sup><span 
class="cmmi-8">j</span></sup> (here <span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmr-8">1</span></sub><sup><span 
class="cmmi-8">ij</span></sup> is the inverse matrix
that represent the contravariant metric induced by <span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmr-8">1</span><span style="margin-left:0.3em" class="thinspace"></span><span 
class="cmmi-8">ij</span></sub>), and <span 
class="cmr-10x-x-109">&#x0393;</span><sub><span 
class="cmmi-8">sk</span></sub><sup><span 
class="cmmi-8">j</span></sup> are the usual
Christoffel symbols of <span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmr-8">1</span><span style="margin-left:0.3em" class="thinspace"></span><span 
class="cmmi-8">ij</span></sub>.
<!--l. 1700--><p class="noindent" >The operator <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">2</span></sub> has the general structure
<table 
class="equation"><tr><td><a 
 id="x131-336001r63"></a>
<center class="math-display" >
<img 
src="manual145x.png" alt="        ( ij      ij  k)
A2 = Dx  g2 Dx + ck u x Dx,
" class="math-display" ></center></td><td class="equation-label">(16.63)</td></tr></table>
<!--l. 1703--><p class="nopar" >
where the inverse <span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmr-8">2</span><span style="margin-left:0.3em" class="thinspace"></span><span 
class="cmmi-8">ij</span></sub> of the leading term transforms as a covariant pseudo-Riemannian
metric. From now on we drop the subscript <span 
class="cmr-10x-x-109">2 </span>for the metric of <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">2</span></sub>. It was proved in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>
that, if we set <span 
class="cmmi-10x-x-109">c</span><sub><span 
class="cmmi-8">ijk</span></sub> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmmi-8">iq</span></sub><span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmmi-8">jp</span></sub><span 
class="cmmi-10x-x-109">c</span><sub><span 
class="cmmi-8">k</span></sub><sup><span 
class="cmmi-8">pq</span></sup>, then
<center class="math-display" >
<img 
src="manual146x.png" alt="      1-
cijk = 3(gik,j - gij,k)
" class="math-display" ></center>
<!--l. 1710--><p class="nopar" >
and the metric fulfills the following identity:
<table 
class="equation"><tr><td><a 
 id="x131-336002r64"></a>
                                                                     

                                                                     
<center class="math-display" >
<img 
src="manual147x.png" alt="gmk,n + gkn,m + gmn,k = 0.
" class="math-display" ></center></td><td class="equation-label">(16.64)</td></tr></table>
<!--l. 1715--><p class="nopar" >
This means that the metric is a Monge metric <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. In particular, its coefficients are
quadratic in the variables <span 
class="cmmi-10x-x-109">u</span><sup><span 
class="cmmi-8">i</span></sup>. It is easy to input the two operators in CDE. Let us start by
<span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">1</span></sub>: we may define its entries one by one as follows
                                                                     

                                                                     
<div class="verbatim" id="verbatim-705">
operator&#x00A0;a1;
&#x00A0;<br />
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;a1(1,1,psi)&#x00A0;=&#x00A0;-&#x00A0;(3/2)*td(psi,x);
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;a1(1,2,psi)&#x00A0;=&#x00A0;(1/2)*td(a*psi,x);
&#x00A0;<br />...
</div>
<!--l. 1726--><p class="nopar" > We could also use one specialized Reduce package for the computation of
the Christoffel symbols, like <span 
class="pcrr8t-x-x-109">RedTen </span>or <span 
class="pcrr8t-x-x-109">GRG</span>. Assuming that the operators
<span 
class="pcrr8t-x-x-109">gamma_hi(i,j,k) </span>have been defined equal to <span 
class="cmr-10x-x-109">&#x0393;</span><sub><span 
class="cmmi-8">k</span></sub><sup><span 
class="cmmi-8">ij</span></sup> and computed in the
system using the inverse matrix <span 
class="cmmi-10x-x-109">g</span><sub><span 
class="cmmi-8">ij</span></sub> of the leading coefficient contravariant
metric<span class="footnote-mark"><a 
href="manual134.html#fn10x16"><sup class="textsuperscript">10</sup></a></span><a 
 id="x131-336003f10"></a> 
<center class="math-display" >
<img 
src="manual148x.png" alt="     (  3   1            )
 ij   ( -12   2a     3b    )
g  =   2a   b3     22c
        b   2c  2(b - ac)
" class="math-display" ></center>
<!--l. 1743--><p class="nopar" >
then, provided we defined a list <span 
class="pcrr8t-x-x-109">dep_var </span>of the dependent variables, we could
set
                                                                     

                                                                     
<div class="verbatim" id="verbatim-706">
operator&#x00A0;gamma_hi_con;
&#x00A0;<br />for&#x00A0;all&#x00A0;i,j&#x00A0;let&#x00A0;gamma_hi_con(i,j)&#x00A0;=
&#x00A0;<br />(
&#x00A0;<br />&#x00A0;for&#x00A0;k:=1:3&#x00A0;sum&#x00A0;gamma_hi(i,j,k)*mkid(part(dep_var,k),!_x)
&#x00A0;<br />)$
</div>
<!--l. 1752--><p class="nopar" > and
                                                                     

                                                                     
<div class="verbatim" id="verbatim-707">
operator&#x00A0;a1$
&#x00A0;<br />for&#x00A0;all&#x00A0;i,j,psi&#x00A0;let&#x00A0;a1(i,j,psi)&#x00A0;=
&#x00A0;<br />gu1(i,j)*td(psi,x)+(for&#x00A0;k:=1:3&#x00A0;sum&#x00A0;gamma_hi_con(i,j)*psi
&#x00A0;<br />)$
</div>
<!--l. 1759--><p class="nopar" >
<!--l. 1761--><p class="noindent" >The third order operator can be reconstructed as follows. Observe that the leading
contravariant metric is
<center class="math-display" >
<img 
src="manual149x.png" alt="     (               )
 ij   (0   0      1   )
g  =   0  1     - a 2
       1  - a 2b + a
" class="math-display" ></center>
<!--l. 1772--><p class="nopar" >
Introduce the above matrix in REDUCE as <span 
class="pcrr8t-x-x-109">gu3</span>. Then set
                                                                     

                                                                     
<div class="verbatim" id="verbatim-708">
gu3:=gl3**(-1)$
</div>
<!--l. 1776--><p class="nopar" > and define <span 
class="cmmi-10x-x-109">c</span><sub><span 
class="cmmi-8">ijk</span></sub> as
                                                                     

                                                                     
<div class="verbatim" id="verbatim-709">
operator&#x00A0;c_lo$
&#x00A0;<br />for&#x00A0;i:=1:3&#x00A0;do
&#x00A0;<br />&#x00A0;for&#x00A0;j:=1:3&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;for&#x00A0;k:=1:3&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x003C;&#x003C;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;c_lo(i,j,k):=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(1/3)*(df(gl3(k,i),part(dep_var,j))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;-&#x00A0;df(gl3(j,i),part(dep_var,k)))$
&#x00A0;<br />&#x00A0;&#x00A0;&#x003E;&#x003E;$
</div>
<!--l. 1788--><p class="nopar" > Then define <span 
class="cmmi-10x-x-109">c</span><sub><span 
class="cmmi-8">k</span></sub><sup><span 
class="cmmi-8">ij</span></sup>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-710">
templist:={}$
&#x00A0;<br />operator&#x00A0;c_hi$
&#x00A0;<br />for&#x00A0;i:=1:ncomp&#x00A0;do
&#x00A0;<br />&#x00A0;for&#x00A0;j:=1:ncomp&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;for&#x00A0;k:=1:ncomp&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;c_hi(i,j,k):=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x003C;&#x003C;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;templist:=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;for&#x00A0;m:=1:ncomp&#x00A0;join
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;for&#x00A0;n:=1:ncomp&#x00A0;collect
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;gu3(n,i)*gu3(m,j)*c_lo(m,n,k)$
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;templist:=part(templist,0):=plus
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x003E;&#x003E;$
</div>
<!--l. 1804--><p class="nopar" > Introduce the contracted operator
                                                                     

                                                                     
<div class="verbatim" id="verbatim-711">
operator&#x00A0;c_hi_con$
&#x00A0;<br />for&#x00A0;i:=1:ncomp&#x00A0;do
&#x00A0;<br />&#x00A0;for&#x00A0;j:=1:ncomp&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;c_hi_con(i,j):=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x003C;&#x003C;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;templist:=for&#x00A0;k:=1:ncomp&#x00A0;collect
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;c_hi(i,j,k)*mkid(part(dep_var,k),!_x)$
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;templist:=part(templist,0):=plus
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x003E;&#x003E;$
</div>
<!--l. 1816--><p class="nopar" > Finally, define the operator <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">2</span></sub>
                                                                     

                                                                     
<div class="verbatim" id="verbatim-712">
operator&#x00A0;aa2$
&#x00A0;<br />for&#x00A0;all&#x00A0;i,j,psi&#x00A0;let&#x00A0;aa2(i,j,psi)&#x00A0;=
&#x00A0;<br />td(
&#x00A0;<br />gu3(i,j)*td(psi,x,2)+c_hi_con(i,j)*td(psi,x)
&#x00A0;<br />,x)$
</div>
<!--l. 1824--><p class="nopar" > Now, we can test the Hamiltonian property of <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">1</span></sub>, <span 
class="cmmi-10x-x-109">A</span><sub><span 
class="cmr-8">2</span></sub> and their compatibility:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-713">
conv_cdiff2genfun(aa1,sym1)$
&#x00A0;<br />conv_cdiff2genfun(aa2,sym2)$
&#x00A0;<br />
&#x00A0;<br />conv_genfun2biv(sym1,biv1)$
&#x00A0;<br />conv_genfun2biv(sym2,biv2)$
&#x00A0;<br />
&#x00A0;<br />schouten_bracket(biv1,biv1,sb11);
&#x00A0;<br />schouten_bracket(biv1,biv2,sb12);
&#x00A0;<br />schouten_bracket(biv2,biv2,sb22);
</div>
<!--l. 1837--><p class="nopar" > Needless to say, the result of the last three command is a list of zeroes.
<!--l. 1840--><p class="noindent" >We observe that the same software can be used to prove the bi-Hamiltonianity of a
<span 
class="cmr-10x-x-109">6</span>-component WDVV system <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<h4 class="subsectionHead"><span class="titlemark">16.12.21    </span> <a 
 id="x131-33700016.12.21"></a>Schouten bracket of multidimensional operators</h4>
<!--l. 1846--><p class="noindent" >The formulae&#x00A0;(<a 
href="#x131-323002r56">16.56<!--tex4ht:ref: eq:11 --></a>),&#x00A0;(<a 
href="#x131-323003r57">16.57<!--tex4ht:ref: eq:14 --></a>) hold also in the case of multidimensional operators, <span 
class="ptmri8t-x-x-109">ie</span>
operators with total derivatives in more than one independent variables. Here we give one
Hamiltonian operator <span 
class="cmmi-10x-x-109">H </span>and we give two more variational bivectors <span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">1</span></sub>, <span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">2</span></sub>; all
operators are of Dubrovin&#8211;Novikov type (homogeneous). We check the compatibility by
computing <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">H,P</span><sub><span 
class="cmr-8">1</span></sub><span 
class="cmr-10x-x-109">] </span>and <span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">H,P</span><sub><span 
class="cmr-8">2</span></sub><span 
class="cmr-10x-x-109">]</span>. Such computations are standard for the problem of
computing the Hamiltonian cohomology of <span 
class="cmmi-10x-x-109">H</span>.
<!--l. 1854--><p class="noindent" >This example has been provided by M. Casati. The file of the computation is
<span 
class="pcrr8t-x-x-109">dn2d_sb1.red</span>. The dependent variables are <span 
class="cmmi-10x-x-109">p</span><sup><span 
class="cmr-8">1</span></sup>, <span 
class="cmmi-10x-x-109">p</span><sup><span 
class="cmr-8">2</span></sup>.
<!--l. 1857--><p class="noindent" >Let us set <table 
class="gather"><tr><td class="gather1"><img 
src="manual150x.png" alt="     (Dx    0 )
 H =    0  D
     (       y )
P  =  P 111  P112
 1    P 211  P212
" ><a 
 id="x131-337003r65"></a><a 
 id="x131-337004r66"></a></td><td class="equation-label"><br />(16.65)<br /><br />(16.66)<br /></td></tr></table>where
                                                                     

                                                                     
<table 
class="align-star">
         <tr><td 
class="align-odd"><span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">1</span></sub><sup><span 
class="cmr-8">11</span></sup> <span 
class="cmr-10x-x-109">=</span></td>         <td 
class="align-even"><span 
class="cmr-10x-x-109">2</span> <span 
class="cmmi-10x-x-109">&#x2202;g</span>_
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup><span 
class="cmmi-10x-x-109">D</span><sub>
<span 
class="cmmi-8">x</span></sub> <span 
class="cmr-10x-x-109">+</span>  <span 
class="cmmi-10x-x-109">&#x2202;g</span> _
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">xy</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmr-10x-x-109">+</span>    <span 
class="cmmi-10x-x-109">&#x2202;g</span> ___
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span><span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">2</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmr-10x-x-109">+</span>  <span 
class="cmmi-10x-x-109">&#x2202;g</span> _
<span 
class="cmmi-10x-x-109">&#x2202;</span><span 
class="cmr-8">2</span><span 
class="cmmi-10x-x-109">p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup></td>          <td 
class="align-label"></td>         <td 
class="align-label">
         </td></tr><tr><td 
class="align-odd"><span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">1</span></sub><sup><span 
class="cmr-8">21</span></sup> <span 
class="cmr-10x-x-109">=</span></td>         <td 
class="align-even"> <span 
class="cmsy-10x-x-109">- </span><span 
class="cmmi-10x-x-109">fD</span><sub>
<span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">gD</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmr-10x-x-109">+</span>  <span 
class="cmmi-10x-x-109">&#x2202;g</span> _
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup><span 
class="cmmi-10x-x-109">D</span><sub>
<span 
class="cmmi-8">y</span></sub> <span 
class="cmsy-10x-x-109">- </span><span 
class="cmr-10x-x-109">(</span> <span 
class="cmmi-10x-x-109">&#x2202;f</span>_
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup> <span 
class="cmr-10x-x-109">+ 2</span> <span 
class="cmmi-10x-x-109">&#x2202;f</span>_
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">2</span></sup><span 
class="cmr-10x-x-109">)</span><span 
class="cmmi-10x-x-109">D</span><sub>
<span 
class="cmmi-8">x</span></sub></td>         <td 
class="align-label"></td>         <td 
class="align-label">
         </td></tr><tr><td 
class="align-odd"></td>               <td 
class="align-even"> <span 
class="cmsy-10x-x-109">-</span> <span 
class="cmmi-10x-x-109">&#x2202;f</span> _
<span 
class="cmmi-10x-x-109">&#x2202;</span><span 
class="cmr-8">2</span><span 
class="cmmi-10x-x-109">p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">2</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmsy-10x-x-109">-</span>  <span 
class="cmmi-10x-x-109">&#x2202;f</span> ___
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span><span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmsy-10x-x-109">-</span> <span 
class="cmmi-10x-x-109">&#x2202;f</span> _
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmr-8">2</span></sub><sup><span 
class="cmr-8">2</span></sup><span 
class="cmmi-10x-x-109">x</span><span 
class="cmr-10x-x-109">;</span></td>                    <td 
class="align-label"></td>         <td 
class="align-label">
         </td></tr><tr><td 
class="align-odd"><span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">1</span></sub><sup><span 
class="cmr-8">12</span></sup> <span 
class="cmr-10x-x-109">=</span></td>         <td 
class="align-even"><span 
class="cmmi-10x-x-109">fD</span><sub>
<span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmsy-10x-x-109">- </span><span 
class="cmmi-10x-x-109">gD</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmr-10x-x-109">+</span>  <span 
class="cmmi-10x-x-109">&#x2202;f</span> _
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">D</span><sub>
<span 
class="cmmi-8">x</span></sub> <span 
class="cmsy-10x-x-109">-</span><span class="bbig"><img 
src="manual151x.png" alt="("  class="left" align="middle"></span> <span 
class="cmmi-10x-x-109">&#x2202;g</span> _
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmr-10x-x-109">+ 2</span> <span 
class="cmmi-10x-x-109">&#x2202;g</span>_
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">1</span></sup><span class="bbig"><img 
src="manual152x.png" alt=")"  class="left" align="middle"></span><span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmmi-8">y</span></sub></td>          <td 
class="align-label"></td>         <td 
class="align-label">
         </td></tr><tr><td 
class="align-odd"></td>               <td 
class="align-even"> <span 
class="cmsy-10x-x-109">-</span> <span 
class="cmmi-10x-x-109">&#x2202;g</span> _
<span 
class="cmmi-10x-x-109">&#x2202;</span><span 
class="cmr-8">2</span><span 
class="cmmi-10x-x-109">p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">1</span></sup> <span 
class="cmsy-10x-x-109">-</span>  <span 
class="cmmi-10x-x-109">&#x2202;g</span> ___
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span><span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup> <span 
class="cmsy-10x-x-109">-</span> <span 
class="cmmi-10x-x-109">&#x2202;g</span> _
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmr-8">2</span><span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmr-10x-x-109">;</span></td>                     <td 
class="align-label"></td>         <td 
class="align-label">
         </td></tr><tr><td 
class="align-odd"><span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">1</span></sub><sup><span 
class="cmr-8">22</span></sup> <span 
class="cmr-10x-x-109">=</span></td>         <td 
class="align-even"><span 
class="cmr-10x-x-109">2</span> <span 
class="cmmi-10x-x-109">&#x2202;f</span>_
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">D</span><sub>
<span 
class="cmmi-8">y</span></sub> <span 
class="cmr-10x-x-109">+</span>  <span 
class="cmmi-10x-x-109">&#x2202;f</span> _
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">y </span><span 
class="cmr-10x-x-109">+</span>    <span 
class="cmmi-10x-x-109">&#x2202;f</span> ___
<span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">1</span><span 
class="cmmi-10x-x-109">&#x2202;p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">1</span></sup> <span 
class="cmr-10x-x-109">+</span>  <span 
class="cmmi-10x-x-109">&#x2202;f</span> _
<span 
class="cmmi-10x-x-109">&#x2202;</span><span 
class="cmr-8">2</span><span 
class="cmmi-10x-x-109">p</span><span 
class="cmr-8">2</span> <span 
class="cmmi-10x-x-109">p</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmr-8">1</span></sup><span 
class="cmmi-10x-x-109">p</span><sub>
<span 
class="cmmi-8">y</span></sub><sup><span 
class="cmr-8">2</span></sup><span 
class="cmr-10x-x-109">;</span></td>          <td 
class="align-label"></td>         <td 
class="align-label"></td></tr></table>
<!--l. 1898--><p class="noindent" >and let <span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">2</span></sub> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">P</span><sub><span 
class="cmr-8">1</span></sub><sup><span 
class="cmmi-8">T</span> </sup>. This is implemented as follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-714">
mk_cdiffop(aa2,1,{2},2)$
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa2(1,1,psi)&#x00A0;=
&#x00A0;<br />&#x00A0;2*df(g,p1)*p2_y*td(psi,x)&#x00A0;+&#x00A0;df(g,p1)*p2_xy*psi
&#x00A0;<br />&#x00A0;+&#x00A0;df(g,p1,p2)*p2_x*p2_y*psi&#x00A0;+&#x00A0;df(g,p1,2)*p1_x*p2_y*psi;
&#x00A0;<br />
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa2(1,2,psi)&#x00A0;=
&#x00A0;<br />&#x00A0;f*td(psi,x,2)&#x00A0;-&#x00A0;g*td(psi,y,2)&#x00A0;+&#x00A0;df(f,p1)*p1_x*td(psi,x)
&#x00A0;<br />&#x00A0;-&#x00A0;(df(g,p2)*p2_y&#x00A0;+&#x00A0;2*df(g,p1)*p1_y)*td(psi,y)
&#x00A0;<br />&#x00A0;-&#x00A0;df(g,p1,2)*p1_y*p1_y*psi&#x00A0;-&#x00A0;df(g,p1,p2)*p1_y*p2_y*psi
&#x00A0;<br />&#x00A0;-&#x00A0;df(g,p1)*p1_2y*psi;
&#x00A0;<br />
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa2(2,1,psi)&#x00A0;=
&#x00A0;<br />&#x00A0;-&#x00A0;f*td(psi,x,2)&#x00A0;+&#x00A0;g*td(psi,y,2)
&#x00A0;<br />&#x00A0;+&#x00A0;df(g,p2)*p2_y*td(psi,y)
&#x00A0;<br />&#x00A0;-&#x00A0;(df(f,p1)*p1_x+2*df(f,p2)*p2_x)*td(psi,x)
&#x00A0;<br />&#x00A0;-&#x00A0;df(f,p2,2)*p2_x*p2_x*psi&#x00A0;-&#x00A0;df(f,p1,p2)*p1_x*p2_x*psi
&#x00A0;<br />&#x00A0;-&#x00A0;df(f,p2)*p2_2x*psi;
&#x00A0;<br />
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa2(2,2,psi)&#x00A0;=
&#x00A0;<br />&#x00A0;2*df(f,p2)*p1_x*td(psi,y)
&#x00A0;<br />&#x00A0;+&#x00A0;df(f,p2)*p1_xy*psi&#x00A0;+&#x00A0;df(f,p1,p2)*p1_x*p1_y*psi
&#x00A0;<br />&#x00A0;+&#x00A0;df(f,p2,2)*p1_x*p2_y*psi;
&#x00A0;<br />
&#x00A0;<br />mk_cdiffop(aa3,1,{2},2)$
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa3(1,1,psi)&#x00A0;=&#x00A0;aa2(1,1,psi);
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa3(1,2,psi)&#x00A0;=&#x00A0;aa2(2,1,psi);
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa3(2,1,psi)&#x00A0;=&#x00A0;aa2(1,2,psi);
&#x00A0;<br />for&#x00A0;all&#x00A0;psi&#x00A0;let&#x00A0;aa3(2,2,psi)&#x00A0;=&#x00A0;aa2(2,2,psi);
</div>
<!--l. 1928--><p class="nopar" > Let us check the skew-adjointness of the above bivectors:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-715">
conv_cdiff2superfun(aa1,sym1)$
&#x00A0;<br />conv_cdiff2superfun(aa2,sym2)$
&#x00A0;<br />conv_cdiff2superfun(aa3,sym3)$
&#x00A0;<br />
&#x00A0;<br />adjoint_cdiffop(aa1,aa1_star);
&#x00A0;<br />adjoint_cdiffop(aa2,aa2_star);
&#x00A0;<br />adjoint_cdiffop(aa3,aa3_star);
&#x00A0;<br />
&#x00A0;<br />for&#x00A0;i:=1:2&#x00A0;do&#x00A0;write&#x00A0;sym1(i)&#x00A0;+&#x00A0;aa1_star_sf(i);
&#x00A0;<br />for&#x00A0;i:=1:2&#x00A0;do&#x00A0;write&#x00A0;sym2(i)&#x00A0;+&#x00A0;aa2_star_sf(i);
&#x00A0;<br />for&#x00A0;i:=1:2&#x00A0;do&#x00A0;write&#x00A0;sym3(i)&#x00A0;+&#x00A0;aa3_star_sf(i);
</div>
<!--l. 1942--><p class="nopar" > Of course the last three commands produce two zeros each.
<!--l. 1945--><p class="noindent" >Let us compute Schouten brackets.
                                                                     

                                                                     
<div class="verbatim" id="verbatim-716">
conv_cdiff2superfun(aa1,sym1)$
&#x00A0;<br />conv_cdiff2superfun(aa2,sym2)$
&#x00A0;<br />conv_cdiff2superfun(aa3,sym3)$
&#x00A0;<br />
&#x00A0;<br />conv_genfun2biv(sym1,biv1)$
&#x00A0;<br />conv_genfun2biv(sym2,biv2)$
&#x00A0;<br />conv_genfun2biv(sym3,biv3)$
&#x00A0;<br />
&#x00A0;<br />schouten_bracket(biv1,biv1,sb11);
&#x00A0;<br />schouten_bracket(biv1,biv2,sb12);
&#x00A0;<br />schouten_bracket(biv1,biv3,sb13);
</div>
<!--l. 1958--><p class="nopar" > <span 
class="pcrr8t-x-x-109">sb11(1) </span>is trivially a list of zeros, while <span 
class="pcrr8t-x-x-109">sb12(1) </span>is nonzero and <span 
class="pcrr8t-x-x-109">sb13(1) </span>is again
zero.
<!--l. 1964--><p class="noindent" >More formulae are currently being implemented in the system, like symplecticity and
Nijenhuis condition for recursion operators <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. Interested readers are warmly invited to
contact R. Vitolo for questions/feature requests.
<!--l. 1969--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.22    </span> <a 
 id="x131-33800016.12.22"></a>Non-local operators</h4>
<!--l. 1972--><p class="noindent" >In this section we will show an experimental way to find nonlocal operators. The word
&#8216;experimental&#8217; comes from the lack of a comprehensive mathematical theory of nonlocal
operators; in particular, it is still missing a theoretical framework for Schouten brackets
of nonlocal opeartors in the odd variable language.
<!--l. 1978--><p class="noindent" >In any case we will achieve the results by means of a covering of the cotangent covering.
Indeed, it can be proved that there is a <span 
class="cmr-10x-x-109">1 </span><span 
class="cmsy-10x-x-109">- </span><span 
class="cmr-10x-x-109">1 </span>correspondence between (higher)
symmetries of the initial equation and conservation laws on the cotangent covering. Such
conservation laws provide new potential variables, hence a covering (see <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span> for
theoretical details on coverings).
<!--l. 1984--><p class="noindent" >In Section&#x00A0;<a 
href="#x131-34100016.12.25">16.12.25<!--tex4ht:ref: cdesec:plebanski-equation --></a> we will also discuss a procedure for finding conservation laws from
their generating functions that is of independent interest.
<!--l. 1989--><p class="noindent" >
                                                                     

                                                                     
<h4 class="subsectionHead"><span class="titlemark">16.12.23    </span> <a 
 id="x131-33900016.12.23"></a>Non-local Hamiltonian operators for the Korteweg&#8211;de Vries equation</h4>
<!--l. 1992--><p class="noindent" >Here we will compute some nonlocal Hamiltonian operators for the KdV equation. The
result of the computation (without the details below) has been published in
<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 1996--><p class="noindent" >We have to solve equations of the type <span 
class="pcrr8t-x-x-109">ddx(ct)-ddt(cx) </span>as in&#x00A0;<a 
href="#x131-32900016.12.13">16.12.13<!--tex4ht:ref: cdesec:local-cons-laws --></a>.
The main difference is that we will attempt a solution on the <span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup>-covering (see
Subsection&#x00A0;<a 
href="#x131-33000016.12.14">16.12.14<!--tex4ht:ref: cdesec:local-hamilt-oper --></a>). For this reason, first of all we have to determine covering
variables with the usual mechanism of introducing them through conservation laws, this
time on the <span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup>-covering.
<!--l. 2003--><p class="noindent" >As a first step, let us compute conservation laws on the <span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup>-covering whose components
are linear in the <span 
class="cmmi-10x-x-109">p</span>&#8217;s. This computation can be found in the file <span 
class="pcrr8t-x-x-109">kdv_nlcl1 </span>and related
results and debug files.
<!--l. 2007--><p class="noindent" >The conservation laws that we are looking for are in <span 
class="cmr-10x-x-109">1 </span><span 
class="cmsy-10x-x-109">- </span><span 
class="cmr-10x-x-109">1 </span>correspondence with
symmetries of the initial equation <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. We will look for conservatoin laws which
correspond to Galilean boost, <span 
class="cmmi-10x-x-109">x</span>-translation, <span 
class="cmmi-10x-x-109">t</span>-translation at the same time. In the
case of 2 independent variables and 1 dependent variable, one could prove that
one component of such conservation laws can always be written as <span 
class="pcrr8t-x-x-109">sym*p </span>as
follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-717">
c1x:=(t*u_x+1)*p$&#x00A0;%&#x00A0;degree&#x00A0;1
&#x00A0;<br />c2x:=u_x*p$&#x00A0;%&#x00A0;degree&#x00A0;4
&#x00A0;<br />c3x:=(u*u_x+u_3x)*p$&#x00A0;%&#x00A0;degree&#x00A0;6
</div>
<!--l. 2017--><p class="nopar" > The second component must be found by solving an equation. To this aim we produce
the ansatz
                                                                     

                                                                     
<div class="verbatim" id="verbatim-718">
c1t:=f1*p+f2*p_x+f3*p_2x$
&#x00A0;<br />%&#x00A0;degree&#x00A0;6
&#x00A0;<br />c2t:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linodd6&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
&#x00A0;<br />%&#x00A0;degree&#x00A0;8
&#x00A0;<br />c3t:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linodd8&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 2026--><p class="nopar" > where we already introduced the sets <span 
class="pcrr8t-x-x-109">linodd6 </span>and <span 
class="pcrr8t-x-x-109">linodd8 </span>of <span 
class="cmr-10x-x-109">6</span>-th and <span 
class="cmr-10x-x-109">8</span>-th degree
monomials which are linear in odd variables (see the source code). For the first
conservation law solutions of the equation
                                                                     

                                                                     
<div class="verbatim" id="verbatim-719">
equ&#x00A0;1:=td(c1t,x)&#x00A0;-&#x00A0;td(c1x,t);
</div>
<!--l. 2032--><p class="nopar" > are found by hand due to the presence of &#8216;t&#8217; in the symmetry:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-720">
f3:=t*u_x+1$
&#x00A0;<br />f2:=-td(f3,x)$
&#x00A0;<br />f1:=u*f3+td(f3,x,2)$
</div>
<!--l. 2038--><p class="nopar" > We also have the equations
                                                                     

                                                                     
<div class="verbatim" id="verbatim-721">
equ&#x00A0;2:=td(c2t,x)-td(c2x,t);
&#x00A0;<br />equ&#x00A0;3:=td(c3t,x)-td(c3x,t);
</div>
<!--l. 2043--><p class="nopar" > They are solved in the usual way (see the source code of the example and the results file
<span 
class="pcrr8t-x-x-109">kdv_nlcl1_res</span>).
<!--l. 2047--><p class="noindent" >Now, we solve the equation for shadows of nonlocal symmetries in a covering of the
<span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup>-covering (source file <span 
class="pcrr8t-x-x-109">kdv_nlho1</span>). We can produce such a covering by introducing
three new nonlocal (potential) variables <span 
class="pcrr8t-x-x-109">ra,rb,rc</span>. We are going to look for non-local
Hamiltonian operators depending linearly on one of these variables. To this aim we
modify the odd part of the equation to include the components of the above
conservation laws as the derivatives of the new non-local variables <span 
class="pcrr8t-x-x-109">r1</span>, <span 
class="pcrr8t-x-x-109">r2</span>,
<span 
class="pcrr8t-x-x-109">r3</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-722">
principal_odd:={p_t,r1_x,r1_t,r2_x,r2_t,r3_x,r3_t}$
&#x00A0;<br />de_odd:={u*p_x+p_3x,
&#x00A0;<br />p*(t*u_x&#x00A0;+&#x00A0;1),
&#x00A0;<br />p*t*u*u_x&#x00A0;+&#x00A0;p*t*u_3x&#x00A0;+&#x00A0;p*u&#x00A0;+&#x00A0;p_2x*t*u_x&#x00A0;+&#x00A0;p_2x
&#x00A0;<br />&#x00A0;-&#x00A0;p_x*t*u_2x,
&#x00A0;<br />p*u_x,
&#x00A0;<br />p*u*u_x&#x00A0;+&#x00A0;p*u_3x&#x00A0;+&#x00A0;p_2x*u_x&#x00A0;-&#x00A0;p_x*u_2x,
&#x00A0;<br />p*(u*u_x&#x00A0;+&#x00A0;u_3x),
&#x00A0;<br />p*u**2*u_x&#x00A0;+&#x00A0;2*p*u*u_3x&#x00A0;+&#x00A0;3*p*u_2x*u_x&#x00A0;+&#x00A0;p*u_5x
&#x00A0;<br />&#x00A0;+&#x00A0;p_2x*u*u_x&#x00A0;+&#x00A0;p_2x*u_3x&#x00A0;-&#x00A0;p_x*u*u_2x
&#x00A0;<br />&#x00A0;-&#x00A0;p_x*u_4x&#x00A0;-&#x00A0;p_x*u_x**2}$
</div>
<!--l. 2067--><p class="nopar" > The scale degree analysis of the local Hamiltonian operators of the KdV equation leads
to the formulation of the ansatz
                                                                     

                                                                     
<div class="verbatim" id="verbatim-723">
phi:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linodd&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 2072--><p class="nopar" > where <span 
class="pcrr8t-x-x-109">linext </span>is the list of graded mononials which are linear in odd variables and
have degree <span 
class="cmr-10x-x-109">7 </span>(see the source file). The equation for shadows of nonlocal symmetries in
<span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup>-covering
                                                                     

                                                                     
<div class="verbatim" id="verbatim-724">
equ&#x00A0;1:=td(phi,t)-u*td(phi,x)-u_x*phi-td(phi,x,3);
</div>
<!--l. 2078--><p class="nopar" > is solved in the usual way, obtaining (in odd variables notation):
                                                                     

                                                                     
<div class="verbatim" id="verbatim-725">
phi&#x00A0;:=&#x00A0;(c(5)*(4*p*u*u_x&#x00A0;+&#x00A0;3*p*u_3x&#x00A0;+&#x00A0;18*p_2x*u_x
&#x00A0;<br />&#x00A0;+&#x00A0;12*p_3x*u&#x00A0;+&#x00A0;9*p_5x&#x00A0;+&#x00A0;4*p_x*u**2
&#x00A0;<br />&#x00A0;+&#x00A0;12*p_x*u_2x&#x00A0;-&#x00A0;r2*u_x))/4$
</div>
<!--l. 2084--><p class="nopar" > Higher non-local Hamiltonian operators could also be found <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. The CRACK approach
also holds for non-local computations.
<!--l. 2090--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.24    </span> <a 
 id="x131-34000016.12.24"></a>Non-local recursion operator for the Korteweg&#8211;de Vries equation</h4>
<!--l. 2093--><p class="noindent" >Following the ideas in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>, a differential operator that sends symmetries into symmetries
can be found as a shadow of symmetry on the <span 
class="cmmi-10x-x-109">&#x2113;</span>-covering of the KdV equation, with the
further condition that the shadows must be linear in the covering <span 
class="cmmi-10x-x-109">q</span>-variables. The tangent
covering of the KdV equation is
<center class="math-display" >
<img 
src="manual153x.png" alt="{
   ut = uxxx + uux
   qt = uxq + uqx + qxxx
" class="math-display" ></center>
<!--l. 2103--><p class="nopar" >
and we have to solve the equation <span class="bar-css"><span 
class="cmmi-10x-x-109">&#x2113;</span></span><sub><span 
class="cmmi-8">KdV</span> </sub><span 
class="cmr-10x-x-109">(</span><span 
class="cmtt-10x-x-109">phi</span><span 
class="cmr-10x-x-109">) = 0</span>, where <span class="bar-css"><span 
class="cmmi-10x-x-109">&#x2113;</span></span><sub><span 
class="cmmi-8">KdV</span> </sub> means that the
linearization of the KdV equation is lifted over the tangent covering.
<!--l. 2108--><p class="noindent" >The file containing this example is <span 
class="pcrr8t-x-x-109">kdv_ro1.red</span>. The example closely follows the
computational scheme presented in <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 2111--><p class="noindent" >Usually, recursion operators are non-local: operators of the form <span 
class="cmmi-10x-x-109">D</span><sub><span 
class="cmmi-8">x</span></sub><sup><span 
class="cmsy-8">-</span><span 
class="cmr-8">1</span></sup> appear in their
expression. Geometrically we interpret this kind of operator as follows. We introduce a
conservation law on the cotangent covering of the form
<center class="math-display" >
<img 
src="manual154x.png" alt="&#x03C9; = rtdx+ rxdt
" class="math-display" ></center>
<!--l. 2117--><p class="nopar" >
where <span 
class="cmmi-10x-x-109">rt </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">uq </span><span 
class="cmr-10x-x-109">+ </span><span 
class="cmmi-10x-x-109">q</span><sub><span 
class="cmmi-8">xx</span></sub> and <span 
class="cmmi-10x-x-109">rx </span><span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">q</span>. It has the remarkable feature of being linear with
                                                                     

                                                                     
respect to <span 
class="cmmi-10x-x-109">q</span>-variables. A non-local variable <span 
class="cmmi-10x-x-109">r </span>can be introduced as a potential of <span 
class="cmmi-10x-x-109">&#x03C9;</span>, as
<span 
class="cmmi-10x-x-109">r</span><sub><span 
class="cmmi-8">x</span></sub> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">rx</span>, <span 
class="cmmi-10x-x-109">r</span><sub><span 
class="cmmi-8">t</span></sub> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">rt</span>. A computation of shadows of symmetries on the system of
PDEs
<center class="math-display" >
<img 
src="manual155x.png" alt="(  u  = u   + uu
||{   t    xxx     x
   qt = uxq + uqx + qxxx
||(  rt = uq + qxx
   rx = q
" class="math-display" ></center>
<!--l. 2129--><p class="nopar" >
yields, analogously to the previous computations,
                                                                     

                                                                     
<div class="verbatim" id="verbatim-726">
&#x00A0;&#x00A0;2*c(5)*q*u&#x00A0;+&#x00A0;3*c(5)*q_2x&#x00A0;+&#x00A0;c(5)*r*u_x&#x00A0;+&#x00A0;c(2)*q.
</div>
<!--l. 2133--><p class="nopar" > The operator <span 
class="cmmi-10x-x-109">q </span>stands for the identity operator, which is (and must be!) always a
solution; the other solution corresponds to the Lenard&#8211;Magri operator
<center class="math-display" >
<img 
src="manual156x.png" alt="                -1
3Dxx + 2u + uxD x .
" class="math-display" ></center>
<!--l. 2138--><p class="nopar" >
<!--l. 2141--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.25    </span> <a 
 id="x131-34100016.12.25"></a>Non-local Hamiltonian-recursion operators for Plebanski equation</h4>
<!--l. 2144--><p class="noindent" >The Plebanski (or second Heavenly) equation
<table 
class="equation"><tr><td><a 
 id="x131-341001r67"></a>
<center class="math-display" >
<img 
src="manual157x.png" alt="F = uttuxx - u2tx + uxz + uty = 0
" class="math-display" ></center></td><td class="equation-label">(16.67)</td></tr></table>
<!--l. 2148--><p class="nopar" >
is Lagrangian. This means that its linearization is self-adjoint: <span 
class="cmmi-10x-x-109">&#x2113;</span><sub><span 
class="cmmi-8">F</span> </sub> <span 
class="cmr-10x-x-109">= </span><span 
class="cmmi-10x-x-109">&#x2113;</span><sub><span 
class="cmmi-8">F</span> </sub><sup><span 
class="cmsy-8">*</span></sup>, so that the
tangent and cotangent covering coincide, its odd equation being
<table 
class="equation"><tr><td><a 
 id="x131-341002r68"></a>
                                                                     

                                                                     
<center class="math-display" >
<img 
src="manual158x.png" alt="&#x2113;F (p) = pxz + pty - 2utxptx + u2xp2t + u2tp2x = 0.
" class="math-display" ></center></td><td class="equation-label">(16.68)</td></tr></table>
<!--l. 2155--><p class="nopar" >
<!--l. 2157--><p class="noindent" >It is not difficult to realize that the above equation can be written in explicit conservative
form as <table 
class="multline-star"><tr><td><img 
src="manual159x.png" alt="p  + p  + u  p  + u  p  - 2u  p
 xz   ty   tt xx   xx tt    tx tx
              = Dx (pz + uttpx - utxpt)+ Dt (py + uxxpt - utxpx) = 0, " ></td></tr></table>thus
the corresponding conservation law is
<table 
class="equation"><tr><td><a 
 id="x131-341003r69"></a>
<center class="math-display" >
<img 
src="manual160x.png" alt="&#x03C5;(1) = (py + uxxpt - utxpx)dx &#x2227; dy &#x2227; dz + (utxpt - pz - uttpx)dt&#x2227; dy &#x2227; dz.
" class="math-display" ></center></td><td class="equation-label">(16.69)</td></tr></table>
<!--l. 2168--><p class="nopar" >
We can introduce a potential <span 
class="cmmi-10x-x-109">r </span>for the above <span 
class="cmr-10x-x-109">2</span>-component conservation law. Namely, we
can assume that
<table 
class="equation"><tr><td><a 
 id="x131-341004r70"></a>
                                                                     

                                                                     
<center class="math-display" >
<img 
src="manual161x.png" alt="rx = py + uxxpt - utxpx, rt = utxpt - pz - uttpx.
" class="math-display" ></center></td><td class="equation-label">(16.70)</td></tr></table>
<!--l. 2173--><p class="nopar" >
This is a new nonlocal variable for the (co)tangent covering of the Plebanski equation.
We can load the Plebanski equation together with its nonlocal variable <span 
class="cmmi-10x-x-109">r </span>as
follows:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-727">
indep_var:={t,x,y,z}$
&#x00A0;<br />dep_var:={u}$
&#x00A0;<br />odd_var:={p,r}$
&#x00A0;<br />deg_indep_var:={-1,-1,-4,-4}$
&#x00A0;<br />deg_dep_var:={1}$
&#x00A0;<br />deg_odd_var:={1,4}$
&#x00A0;<br />total_order:=6$
&#x00A0;<br />principal_der:={u_xz}$
&#x00A0;<br />de:={-u_ty+u_tx**2-u_2t*u_2x}$
&#x00A0;<br />%&#x00A0;rhs&#x00A0;of&#x00A0;the&#x00A0;equations&#x00A0;that&#x00A0;define&#x00A0;the&#x00A0;nonlocal&#x00A0;variable
&#x00A0;<br />rt:=&#x00A0;-&#x00A0;p_z&#x00A0;-&#x00A0;u_2t*p_x&#x00A0;+&#x00A0;u_tx*p_t$
&#x00A0;<br />rx:=&#x00A0;p_y&#x00A0;+&#x00A0;u_2x*p_t&#x00A0;-&#x00A0;u_tx*p_x$
&#x00A0;<br />%&#x00A0;We&#x00A0;add&#x00A0;conservation&#x00A0;laws&#x00A0;as&#x00A0;new&#x00A0;nonlocal&#x00A0;odd&#x00A0;variables;
&#x00A0;<br />principal_odd:={p_xz,r_x,r_t}$
&#x00A0;<br />%
&#x00A0;<br />de_odd:={-p_ty+2*u_tx*p_tx-u_2x*p_2t-u_2t*p_2x,rx,rt}$
</div>
<!--l. 2194--><p class="nopar" > We can easily verify that the integrability condition for the new nonlocal variable
holds:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-728">
td(r,t,x)&#x00A0;-&#x00A0;td(r,x,t);
</div>
<!--l. 2199--><p class="nopar" > the result is <span 
class="cmr-10x-x-109">0</span>.
<!--l. 2202--><p class="noindent" >Now, we look for nonlocal recursion operators in the tangent covering using the new
nonlocal odd variable <span 
class="cmmi-10x-x-109">r</span>. We can load the equation exactly as before. We look for
recursion operators which depend on <span 
class="cmmi-10x-x-109">r </span>(which has scale degree <span 
class="cmr-10x-x-109">4</span>); we produce the
following ansatz for <span 
class="pcrr8t-x-x-109">phi</span>:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-729">
linodd:=mkalllinodd(gradmon,l_grad_odd,1,4)$
&#x00A0;<br />phi:=(for&#x00A0;each&#x00A0;el&#x00A0;in&#x00A0;linodd&#x00A0;sum&#x00A0;(c(ctel:=ctel+1)*el))$
</div>
<!--l. 2209--><p class="nopar" > then we solve the equation of shadows of symmetries:
                                                                     

                                                                     
<div class="verbatim" id="verbatim-730">
equ&#x00A0;1:=td(phi,x,z)+td(phi,t,y)-2*u_tx*td(phi,t,x)
&#x00A0;<br />+u_2x*td(phi,t,2)+u_2t*td(phi,x,2)$
</div>
<!--l. 2214--><p class="nopar" > The solution is
                                                                     

                                                                     
<div class="verbatim" id="verbatim-731">
phi&#x00A0;:=&#x00A0;c(28)*r&#x00A0;+&#x00A0;c(1)*p
</div>
<!--l. 2218--><p class="nopar" > hence we obtain the identity operator <span 
class="cmmi-10x-x-109">p </span>and the new nonlocal operator <span 
class="cmmi-10x-x-109">r</span>. It can be proved
that changing coordinates to the evolutionary presentation yields the local operator
(which has a much more complex expression than the identity operator) and one of the
nonlocal operators of <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>. More details on this computation can be found in
<span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
<!--l. 2228--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">16.12.26    </span> <a 
 id="x131-34200016.12.26"></a>Appendix: old versions of CDE</h4>
<!--l. 2230--><p class="noindent" >A short version history is provided here.
<!--l. 2232--><p class="noindent" ><span class="paragraphHead"><a 
 id="x131-34300016.12.26"></a><span 
class="ptmb8t-x-x-109">CDE 1.0</span></span>
This version was published in October 2014. It was programmed in REDUCE&#8217;s
<span 
class="ptmb8t-x-x-109">algebraic mode</span>, so its capabilities were limited, and its speed was severely affected by
the systematic use of the package <span 
class="pcrr8t-x-x-109">assist </span>for manipulating algebraic lists. Its features
were:
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x131-343002x1">CDE  1.0  is  able  to  do  standard  computations  in  integrable  systems  like
     determining systems for generalized symmetries and conservation laws.
     </li>
     <li 
  class="enumerate" id="x131-343004x2">CDE  1.0  is  able  to  compute  linear  overdetermined  systems  of  partial
     differential equations whose solutions are Hamiltonian operators.
     </li>
     <li 
  class="enumerate" id="x131-343006x3">CDE is able to compute Schouten brackets between bivectors. This can be
     used <span 
class="ptmri8t-x-x-109">eg </span>to check Hamiltonianity of an operator, or the compatibility of two
     operators.</li></ol>
<!--l. 2245--><p class="noindent" >CDE 1.0 has never ben included in the official REDUCE distribution, and it is still
available at <span class="cite">[<span 
class="ptmb8t-x-x-109">?</span>]</span>.
                                                                     

                                                                     
<!--l. 2248--><p class="noindent" >
<h4 class="likesubsectionHead"><a 
 id="x131-344000"></a>Bibliography</h4>
<!--l. 2248--><p class="noindent" >
     <div class="thebibliography">
     <p class="bibitem" ><span class="biblabel">
  [1]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xgdeq"></a>Geometry of Differential Equations web site: <a 
href="http://gdeq.org" class="url" ><span 
class="pcrr8t-x-x-109">http://gdeq.org</span></a>.
     </p>
     <p class="bibitem" ><span class="biblabel">
  [2]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XMany"></a><span 
class="ptmrc8t-x-x-109">A.   V.   B<span 
class="small-caps">O</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>,   V.   N.   C<span 
class="small-caps">H</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>,   S.   V.   D<span 
class="small-caps">U</span><span 
class="small-caps">Z</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">N</span>,   N.</span>
     <span 
class="ptmrc8t-x-x-109">G.  K<span 
class="small-caps">H</span><span 
class="small-caps">O</span><span 
class="small-caps">R</span></span><span 
class="cmsy-10x-x-109">&#x2032;</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">K</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">A</span>,  I.  S.  K<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">L</span></span><span 
class="cmsy-10x-x-109">&#x2032;</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">S</span><span 
class="small-caps">H</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span>,  A.  V.  S<span 
class="small-caps">A</span><span 
class="small-caps">M</span><span 
class="small-caps">O</span><span 
class="small-caps">K</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">N</span>,  Y<span 
class="small-caps">U</span>.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;N.</span>
     <span 
class="ptmrc8t-x-x-109">T<span 
class="small-caps">O</span><span 
class="small-caps">R</span><span 
class="small-caps">K</span><span 
class="small-caps">H</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>, A. M. V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span> <span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span> A. M. V<span 
class="small-caps">I</span><span 
class="small-caps">N</span><span 
class="small-caps">O</span><span 
class="small-caps">G</span><span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">D</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span></span>: Symmetries
     and Conservation Laws for Differential Equations of Mathematical Physics,
     I.  S.  Krasil<span 
class="cmsy-10x-x-109">&#x2032;</span>shchik  and  A.  M.  Vinogradov  eds.,  Translations  of  Math.
     Monographs <span 
class="ptmb8t-x-x-109">182</span>, Amer.&#x00A0;Math.&#x00A0;Soc. (1999).
     </p>
     <p class="bibitem" ><span class="biblabel">
  [3]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XBH10"></a><span 
class="ptmrc8t-x-x-109">D.  B<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">D</span><span 
class="small-caps">W</span><span 
class="small-caps">I</span><span 
class="small-caps">N</span>,  W.  H<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">E</span><span 
class="small-caps">M</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span></span>,  <span 
class="ptmri8t-x-x-109">A  symbolic  algorithm  for  computing</span>
     <span 
class="ptmri8t-x-x-109">recursion operators of nonlinear partial differential equations</span>, International
     Journal of Computer Mathematics, vol. 87 (5), pp. 1094-1119 (2010).
     </p>
     <p class="bibitem" ><span class="biblabel">
  [4]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XDub"></a><span 
class="ptmrc8t-x-x-109">B.A. D<span 
class="small-caps">U</span><span 
class="small-caps">B</span><span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">I</span><span 
class="small-caps">N</span></span>,   Geometry of 2D topological field theories, Lecture
     Notes in Math. 1620, Springer-Verlag (1996) 120&#8211;348.
     </p>
     <p class="bibitem" ><span class="biblabel">
  [5]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XDN"></a><span 
class="ptmrc8t-x-x-109">B.A.                                                                                          D<span 
class="small-caps">U</span><span 
class="small-caps">B</span><span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">I</span><span 
class="small-caps">N</span></span>
     <span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span> S.P. N<span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span></span>, Hamiltonian formalism of one-dimensional systems of
     hydrodynamic type and the Bogolyubov-Whitham averaging method, Soviet
     Math. Dokl. <span 
class="ptmb8t-x-x-109">27 </span>No. 3 (1983) 665&#8211;669.
     </p>
     <p class="bibitem" ><span class="biblabel">
  [6]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XDN2"></a><span 
class="ptmrc8t-x-x-109">B.A.              D<span 
class="small-caps">U</span><span 
class="small-caps">B</span><span 
class="small-caps">R</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">I</span><span 
class="small-caps">N</span>              <span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span>              S.P.              N<span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span></span>,
     Poisson brackets of hydrodynamic type, Soviet Math. Dokl. <span 
class="ptmb8t-x-x-109">30 </span>No. 3 (1984),
     651&#8211;2654.
     </p>
                                                                     

                                                                     
     <p class="bibitem" ><span class="biblabel">
  [7]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XFN"></a><span 
class="ptmrc8t-x-x-109">E.V.   F<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">P</span><span 
class="small-caps">O</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>,   C.A.P.   G<span 
class="small-caps">A</span><span 
class="small-caps">L</span><span 
class="small-caps">V</span><span 
class="small-caps">A</span><span 
class="small-caps">O</span>,   O.   M<span 
class="small-caps">O</span><span 
class="small-caps">K</span><span 
class="small-caps">H</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>,   Y.   N<span 
class="small-caps">U</span><span 
class="small-caps">T</span><span 
class="small-caps">K</span><span 
class="small-caps">U</span></span>,
     Bi-Hamiltonian structure of equations of associativity in 2-d topological field
     theory, Comm. Math. Phys. <span 
class="ptmb8t-x-x-109">186 </span>(1997) 649-669.
     </p>
     <p class="bibitem" ><span class="biblabel">
  [8]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xfpv"></a><span 
class="ptmrc8t-x-x-109">E.V. F<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">P</span><span 
class="small-caps">O</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>, M.V. P<span 
class="small-caps">A</span><span 
class="small-caps">V</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>, R.F. V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>, <span 
class="ptmri8t-x-x-109">Projective-geometric</span>
     <span 
class="ptmri8t-x-x-109">aspects                                                                                                            of</span>
     <span 
class="ptmri8t-x-x-109">homogeneous third-order Hamiltonian operators</span>, J. Geom.&#x00A0;Phys.&#x00A0;<span 
class="ptmb8t-x-x-109">85 </span>(2014)
     16-28, DOI: 10.1016/j.geomphys.2014.05.027.
     </p>
     <p class="bibitem" ><span class="biblabel">
  [9]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xfpv2"></a><span 
class="ptmrc8t-x-x-109">E.V.              F<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">P</span><span 
class="small-caps">O</span><span 
class="small-caps">N</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>,              M.V.              P<span 
class="small-caps">A</span><span 
class="small-caps">V</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>,              R.F.</span>
     <span 
class="ptmrc8t-x-x-109">V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>, <span 
class="ptmri8t-x-x-109">Towards the classification of homogeneous third-order Hamiltonian</span>
     <span 
class="ptmri8t-x-x-109">operators</span>, <a 
href="http://arxiv.org/abs/1508.02752" class="url" ><span 
class="pcrr8t-x-x-109">http://arxiv.org/abs/1508.02752</span></a>
     </p>
     <p class="bibitem" ><span class="biblabel">
 [10]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xgetz"></a><span 
class="ptmri8t-x-x-109">E. Getzler</span>, A Darboux theorem for Hamiltonian operators in the formal
     calculus of variations, Duke J. Math. <span 
class="ptmb8t-x-x-109">111 </span>(2002), 535-560.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [11]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XIVV"></a><span 
class="ptmrc8t-x-x-109">S.     I<span 
class="small-caps">G</span><span 
class="small-caps">O</span><span 
class="small-caps">N</span><span 
class="small-caps">I</span><span 
class="small-caps">N</span>,     A.     V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span>,     R.     V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span>:     </span><span 
class="ptmri8t-x-x-109">Variational</span>
     <span 
class="ptmri8t-x-x-109">Multivectors    and    Brackets    in    the    Geometry    of    Jet    Spaces</span>,    V
     Int.    Conf.    on    on    Symmetry    in    Nonlinear    Mathematical    Physics,
     Kyiv   2003;   Part   3   of   Volume   50   of   Proceedings   of   Institute   of
     Mathematics    of    NAS    of    Ukraine,    Editors    A.G.    Nikitin,    V.M.
     Boyko,   R.O.   Popovych   and   I.A.   Yehorchenko   (2004),   1335&#8211;1342;
     <a 
href="http://www.imath.kiev.ua/~snmp2003/Proceedings/vitolo.pdf" class="url" ><span 
class="pcrr8t-x-x-109">http://www.imath.kiev.ua/~snmp2003/Proceedings/vitolo.pdf</span></a>.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [12]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XKKV"></a><span 
class="ptmrc8t-x-x-109">P.H.M.   K<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">S</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span>,   I.S.   K<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">L</span>&#8217;<span 
class="small-caps">S</span><span 
class="small-caps">H</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span>,   A.M.   V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span>,</span>
     <span 
class="ptmri8t-x-x-109">Hamiltonian operators and </span><span 
class="cmmi-10x-x-109">&#x2113;</span><sup><span 
class="cmsy-8">*</span></sup><span 
class="ptmri8t-x-x-109">-covering</span>, Journal of Geometry and Physics <span 
class="ptmb8t-x-x-109">50</span>
     (2004), 273&#8211;302.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [13]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XKKV2"></a><span 
class="ptmrc8t-x-x-109">P.H.M.  K<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">S</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span>,  I.S.  K<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">L</span>&#8217;<span 
class="small-caps">S</span><span 
class="small-caps">H</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span>,  A.M.  V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span>,  </span><span 
class="ptmri8t-x-x-109">A</span>
     <span 
class="ptmri8t-x-x-109">geometric study of the dispersionless Boussinesq equation</span>, Acta Appl.&#x00A0;Math.
     <span 
class="ptmb8t-x-x-109">90 </span>(2006), 143&#8211;178.
                                                                     

                                                                     
     </p>
     <p class="bibitem" ><span class="biblabel">
 [14]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>
     <a 
 id="XKerstenKrasilshchikVerbovetskyVitolo:HSGP"></a><span 
class="ptmrc8t-x-x-109">P.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;K<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">S</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">N</span>, I.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;K<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">L</span></span><span 
class="cmsy-10x-x-109">&#x2032;</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">S</span><span 
class="small-caps">H</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span>, A.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span>, <span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span> R.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>,
     <span 
class="ptmri8t-x-x-109">Hamiltonian structures for general PDEs</span>, Differential equations: Geometry,
     Symmetries  and  Integrability.  The  Abel  Symposium  2008  (B.&#x00A0;Kruglikov,
     V.&#x00A0;V. Lychagin, and E.&#x00A0;Straume, eds.), Springer-Verlag, 2009, pp.&#x00A0;187&#8211;198,
     <a 
href="http://arXiv.org/abs/0812.4895" ><span 
class="pcrr8t-x-x-109">arXiv:0812.4895</span></a>.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [15]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XKrVe-JGP-2011"></a><span 
class="ptmrc8t-x-x-109">I.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;K<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">L</span></span><span 
class="cmsy-10x-x-109">&#x2032;</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">S</span><span 
class="small-caps">H</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span>  <span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span>  A.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span></span>,  <span 
class="ptmri8t-x-x-109">Geometry  of  jet  spaces</span>
     <span 
class="ptmri8t-x-x-109">and             integrable             systems</span>,             J.&#x00A0;Geom.&#x00A0;Phys.             (2011)
     doi:10.1016/j.geomphys.2010.10.012, <a 
href="arXiv:1002.0077" class="url" ><span 
class="pcrr8t-x-x-109">arXiv:1002.0077</span></a>.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [16]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XKKV-SPT-2011"></a><span 
class="ptmrc8t-x-x-109">I.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;K<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">L</span></span><span 
class="cmsy-10x-x-109">&#x2032;</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">S</span><span 
class="small-caps">H</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span>,   A.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span>,   R.   V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>,   <span 
class="ptmri8t-x-x-109">A   unified</span>
     <span 
class="ptmri8t-x-x-109">approach to computation of integrable structures</span>, Acta Appl.&#x00A0;Math.&#x00A0;(2012).
     </p>
     <p class="bibitem" ><span class="biblabel">
 [17]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XKVV-book"></a><span 
class="ptmrc8t-x-x-109">I.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;K<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">S</span><span 
class="small-caps">I</span><span 
class="small-caps">L</span></span><span 
class="cmsy-10x-x-109">&#x2032;</span><span 
class="ptmrc8t-x-x-109"><span 
class="small-caps">S</span><span 
class="small-caps">H</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">I</span><span 
class="small-caps">K</span>,  A.</span><span 
class="ptmrc8t-x-x-109">&#x00A0;V<span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">B</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">T</span><span 
class="small-caps">S</span><span 
class="small-caps">K</span><span 
class="small-caps">Y</span>,  R.  V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>,  <span 
class="ptmri8t-x-x-109">The  symbolic</span>
     <span 
class="ptmri8t-x-x-109">computation  of  integrability  structures  for  partial  differential  equations</span>,
     book, to appear in the Springer series &#8220;Texts and monographs in symbolic
     computations&#8221; (2017).
     </p>
     <p class="bibitem" ><span class="biblabel">
 [18]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XKupershmidt:KP"></a><span 
class="ptmrc8t-x-x-109">B.         K<span 
class="small-caps">U</span><span 
class="small-caps">P</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">S</span><span 
class="small-caps">C</span><span 
class="small-caps">H</span><span 
class="small-caps">M</span><span 
class="small-caps">I</span><span 
class="small-caps">D</span><span 
class="small-caps">T</span></span>:         <span 
class="ptmri8t-x-x-109">Geometric         Hamiltonian         forms</span>
     <span 
class="ptmri8t-x-x-109">for  the  Kadomtsev&#8211;Petviashvili  and  Zabolotskaya&#8211;Khokhlov  equations</span>,  in
     Geometry in Partial Differential Equations, A. Prastaro, Th.M. Rassias eds.,
     World Scientific (1994), 155&#8211;172.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [19]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XMar"></a><span 
class="ptmrc8t-x-x-109">M. M<span 
class="small-caps">A</span><span 
class="small-caps">R</span><span 
class="small-caps">V</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span></span>, <span 
class="ptmri8t-x-x-109">Sufficient set of integrability conditions of an orthonomic</span>
     <span 
class="ptmri8t-x-x-109">system</span>. Foundations of Computational Mathematics <span 
class="ptmb8t-x-x-109">9 </span>(2009), 651&#8211;674.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [20]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span>
     <a 
 id="XNeyziNutkuSheftel:JPA:2005"></a><span 
class="ptmrc8t-x-x-109">F. N<span 
class="small-caps">E</span><span 
class="small-caps">Y</span><span 
class="small-caps">Z</span><span 
class="small-caps">I</span>, Y. N<span 
class="small-caps">U</span><span 
class="small-caps">T</span><span 
class="small-caps">K</span><span 
class="small-caps">U</span>, <span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span> M.B. S<span 
class="small-caps">H</span><span 
class="small-caps">E</span><span 
class="small-caps">F</span><span 
class="small-caps">T</span><span 
class="small-caps">E</span><span 
class="small-caps">L</span></span>, <span 
class="ptmri8t-x-x-109">Multi-Hamiltonian structure</span>
     <span 
class="ptmri8t-x-x-109">of Plebanski&#8217;s second heavenly equation </span>J. Phys.&#x00A0;A: Math.&#x00A0;Gen.&#x00A0;<span 
class="ptmb8t-x-x-109">38 </span>(2005),
     8473. <a 
href="http://arXiv.org/abs/nlin/0505030v2" ><span 
class="pcrr8t-x-x-109">arXiv:nlin/0505030v2</span></a>.
                                                                     

                                                                     
     </p>
     <p class="bibitem" ><span class="biblabel">
 [21]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xinside"></a><span 
class="ptmrc8t-x-x-109">A.C. N<span 
class="small-caps">O</span><span 
class="small-caps">R</span><span 
class="small-caps">M</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span>, R. V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>, <span 
class="ptmri8t-x-x-109">Inside Reduce</span>, part of the official REDUCE
     documentation included in the source code, see below.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [22]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xnucci1"></a><span 
class="ptmrc8t-x-x-109">M.C. N<span 
class="small-caps">U</span><span 
class="small-caps">C</span><span 
class="small-caps">C</span><span 
class="small-caps">I</span></span>, <span 
class="ptmri8t-x-x-109">Interactive REDUCE programs for calculating classical,</span>
     <span 
class="ptmri8t-x-x-109">non-classical,  and  approximate  symmetries  of  differential  equations</span>,  in
     Computational  and  Applied  Mathematics  II.  Differential  Equations,  W.F.
     Ames,  and  P.J.  Van  der  Houwen,  Eds.,  Elsevier,  Amsterdam  (1992)  pp.
     345&#8211;350.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [23]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xnucci2"></a><span 
class="ptmrc8t-x-x-109">M.C. N<span 
class="small-caps">U</span><span 
class="small-caps">C</span><span 
class="small-caps">C</span><span 
class="small-caps">I</span></span>, <span 
class="ptmri8t-x-x-109">Interactive REDUCE programs for calculating Lie point,</span>
     <span 
class="ptmri8t-x-x-109">non-classical,  Lie-Bäcklund,  and  approximate  symmetries  of  differential</span>
     <span 
class="ptmri8t-x-x-109">equations: manual and floppy disk</span>, in CRC Handbook of Lie Group Analysis
     of Differential Equations. Vol. 3 N.H. Ibragimov, Ed., CRC Press, Boca Raton
     (1996) pp. 415&#8211;481.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [24]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xrelie"></a><span 
class="ptmrc8t-x-x-109">F.     O<span 
class="small-caps">L</span><span 
class="small-caps">I</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span><span 
class="small-caps">I</span></span>,     <span 
class="ptmrc8t-x-x-109">R<span 
class="small-caps">E</span>L<span 
class="small-caps">I</span><span 
class="small-caps">E</span></span>,     REDUCE     software     and     user     guide,
     <a 
href="http://mat521.unime.it/oliveri/" class="url" ><span 
class="pcrr8t-x-x-109">http://mat521.unime.it/oliveri/</span></a>.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [25]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XOlv"></a><span 
class="ptmrc8t-x-x-109">P. O<span 
class="small-caps">L</span><span 
class="small-caps">V</span><span 
class="small-caps">E</span><span 
class="small-caps">R</span></span>, Applications of Lie Groups to Partial Differential Equations,
     2nd ed, GTM Springer, 1992.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [26]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xpv"></a><span 
class="ptmrc8t-x-x-109">M.V.  P<span 
class="small-caps">A</span><span 
class="small-caps">V</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span><span 
class="small-caps">V</span>,  R.F.  V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>:  <span 
class="ptmri8t-x-x-109">On  the  bi-Hamiltonian  geometry  of  the</span>
     <span 
class="ptmri8t-x-x-109">WDVV equations</span>, <span 
class="pcrr8t-x-x-109">http://arxiv.org/abs/1409.7647</span>
     </p>
     <p class="bibitem" ><span class="biblabel">
 [27]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xsv"></a><span 
class="ptmrc8t-x-x-109">G. S<span 
class="small-caps">A</span><span 
class="small-caps">C</span><span 
class="small-caps">C</span><span 
class="small-caps">O</span><span 
class="small-caps">M</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span><span 
class="small-caps">I</span>, R. V<span 
class="small-caps">I</span><span 
class="small-caps">T</span><span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">O</span></span>: <span 
class="ptmri8t-x-x-109">On the Mathematical and Geometrical</span>
     <span 
class="ptmri8t-x-x-109">Structure  of  the  Determining  Equations  for  Shear  Waves  in  Nonlinear</span>
     <span 
class="ptmri8t-x-x-109">Isotropic    Incompressible    Elastodynamics</span>,    J.    Math.&#x00A0;Phys.&#x00A0;<span 
class="ptmb8t-x-x-109">55    </span>(2014),
     081502.
                                                                     

                                                                     
     </p>
     <p class="bibitem" ><span class="biblabel">
 [28]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xwolfcl"></a><span 
class="ptmrc8t-x-x-109">T.  W<span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">F</span></span>,  <span 
class="ptmri8t-x-x-109">A  comparison  of  four  approaches  to  the  calculation  of</span>
     <span 
class="ptmri8t-x-x-109">conservation  laws</span>,  Euro.&#x00A0;Jnl  of  Applied  Mathematics  13  part  2  (2002)
     129-152.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [29]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xwolfsy"></a><span 
class="ptmrc8t-x-x-109">T. W<span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">F</span></span>, <span 
class="ptmri8t-x-x-109">APPLYSYM - a package for the application of Lie-symmetries</span>,
     software distributed together with the computer algebra system REDUCE,
     (1995).
     </p>
     <p class="bibitem" ><span class="biblabel">
 [30]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xwbde"></a><span 
class="ptmrc8t-x-x-109">T.  W<span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">F</span>,  A.  B<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span></span>,  <span 
class="ptmri8t-x-x-109">Investigating  DEs  with  CRACK  and  Related</span>
     <span 
class="ptmri8t-x-x-109">Programs</span>, SIGSAM Bulletin, Special Issue, (June 1995), p 1-8.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [31]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xwolfsy0"></a><span 
class="ptmrc8t-x-x-109">T.  W<span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">F</span></span>,  <span 
class="ptmri8t-x-x-109">An  efficiency  improved  program  LIEPDE  for  determining</span>
     <span 
class="ptmri8t-x-x-109">Lie-symmetries   of   PDEs</span>,   Proc.of   Modern   Group   Analysis:   advanced
     analytical and computational methods in mathematical physics, Catania, Italy
     Oct.1992, Kluwer Acad.Publ. (1993) 377-385.
     </p>
     <p class="bibitem" ><span class="biblabel">
 [32]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="Xcrack"></a><span 
class="ptmrc8t-x-x-109">T. W<span 
class="small-caps">O</span><span 
class="small-caps">L</span><span 
class="small-caps">F</span>, A. B<span 
class="small-caps">R</span><span 
class="small-caps">A</span><span 
class="small-caps">N</span><span 
class="small-caps">D</span></span>: CRACK, user guide, examples and documentation
     <a 
href="http://lie.math.brocku.ca/Crack_demo.html" class="url" ><span 
class="pcrr8t-x-x-109">http://lie.math.brocku.ca/Crack_demo.html</span></a>.                  For
     applications, see also the publications of T. Wolf.</p></div>
<!--l. 245--><p class="noindent" >
                                                                     

                                                                     
                                                                     

                                                                     
<!--l. 247--><p class="noindent" ><table cellspacing="5"><tr><td class="clinks"><a 
href="manualch16.html#manualse103.html" >Up</a></td><td class="clinks"><a 
href="manualse104.html" >Next</a></td><td class="clinks"><a 
href="manualse102.html" >Prev</a></td><td class="clinks"><a 
href="manualse102.html#tailmanualse102.html" >PrevTail</a></td><td class="clinks"><a 
href="manualse103.html" >Front</a></td></tr></table><a 
 id="tailmanualse103.html"></a>   
</body></html> 
